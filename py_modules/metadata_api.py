#!/usr/bin/env python
# -*- coding: utf-8 -*-

#
# Generated Mon Mar 24 11:16:35 2014 by generateDS.py version 2.12b.
#
# Generated with the ESPA modified version of generateDS.py
# See espa google code project.
# See directory ../tools/generateDS
#

import os
import sys
import getopt
import re as re_
import base64
import StringIO
import urllib2
import datetime as datetime_
from lxml import etree

etree_ = None
Verbose_import_ = False
(
    XMLParser_import_none, XMLParser_import_lxml,
    XMLParser_import_elementtree
) = range(3)
XMLParser_import_library = None
try:
    # lxml
    from lxml import etree as etree_
    XMLParser_import_library = XMLParser_import_lxml
    if Verbose_import_:
        print("running with lxml.etree")
except ImportError:
    try:
        # cElementTree from Python 2.5+
        import xml.etree.cElementTree as etree_
        XMLParser_import_library = XMLParser_import_elementtree
        if Verbose_import_:
            print("running with cElementTree on Python 2.5+")
    except ImportError:
        try:
            # ElementTree from Python 2.5+
            import xml.etree.ElementTree as etree_
            XMLParser_import_library = XMLParser_import_elementtree
            if Verbose_import_:
                print("running with ElementTree on Python 2.5+")
        except ImportError:
            try:
                # normal cElementTree install
                import cElementTree as etree_
                XMLParser_import_library = XMLParser_import_elementtree
                if Verbose_import_:
                    print("running with cElementTree")
            except ImportError:
                try:
                    # normal ElementTree install
                    import elementtree.ElementTree as etree_
                    XMLParser_import_library = XMLParser_import_elementtree
                    if Verbose_import_:
                        print("running with ElementTree")
                except ImportError:
                    raise ImportError(
                        "Failed to import ElementTree from any known place")


def parsexml_(*args, **kwargs):
    if (XMLParser_import_library == XMLParser_import_lxml and
            'parser' not in kwargs):
        # Use the lxml ElementTree compatible parser so that, e.g.,
        #   we ignore comments.
        kwargs['parser'] = etree_.ETCompatXMLParser()
    doc = etree_.parse(*args, **kwargs)
    return doc

#
# User methods
#
# Calls to the methods in these classes are generated by generateDS.py.
# You can replace these methods by re-implementing the following class
#   in a module named generatedssuper.py.

try:
    from generatedssuper import GeneratedsSuper
except ImportError, exp:

    class GeneratedsSuper(object):
        tzoff_pattern = re_.compile(r'(\+|-)((0\d|1[0-3]):[0-5]\d|14:00)$')
        class _FixedOffsetTZ(datetime_.tzinfo):
            def __init__(self, offset, name):
                self.__offset = datetime_.timedelta(minutes=offset)
                self.__name = name
            def utcoffset(self, dt):
                return self.__offset
            def tzname(self, dt):
                return self.__name
            def dst(self, dt):
                return None
        def gds_format_string(self, input_data, input_name=''):
            return input_data
        def gds_validate_string(self, input_data, node, input_name=''):
            if not input_data:
                return ''
            else:
                return input_data
        def gds_format_base64(self, input_data, input_name=''):
            return base64.b64encode(input_data)
        def gds_validate_base64(self, input_data, node, input_name=''):
            return input_data
        def gds_format_integer(self, input_data, input_name=''):
            return '%d' % input_data
        def gds_validate_integer(self, input_data, node, input_name=''):
            return input_data
        def gds_format_integer_list(self, input_data, input_name=''):
            return '%s' % input_data
        def gds_validate_integer_list(self, input_data, node, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    float(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, 'Requires sequence of integers')
            return input_data
        def gds_format_float(self, input_data, input_name=''):
            # ESPA - Changed the float output format to ours
            return ('%.6f' % input_data)
        def gds_validate_float(self, input_data, node, input_name=''):
            return input_data
        def gds_format_float_list(self, input_data, input_name=''):
            return '%s' % input_data
        def gds_validate_float_list(self, input_data, node, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    float(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, 'Requires sequence of floats')
            return input_data
        def gds_format_double(self, input_data, input_name=''):
            # ESPA - Changed the double output format to ours
            return '%.6lf' % input_data
        def gds_validate_double(self, input_data, node, input_name=''):
            return input_data
        def gds_format_double_list(self, input_data, input_name=''):
            return '%s' % input_data
        def gds_validate_double_list(self, input_data, node, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    float(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, 'Requires sequence of doubles')
            return input_data
        def gds_format_boolean(self, input_data, input_name=''):
            return ('%s' % input_data).lower()
        def gds_validate_boolean(self, input_data, node, input_name=''):
            return input_data
        def gds_format_boolean_list(self, input_data, input_name=''):
            return '%s' % input_data
        def gds_validate_boolean_list(self, input_data, node, input_name=''):
            values = input_data.split()
            for value in values:
                if value not in ('true', '1', 'false', '0', ):
                    raise_parse_error(
                        node,
                        'Requires sequence of booleans '
                        '("true", "1", "false", "0")')
            return input_data
        def gds_validate_datetime(self, input_data, node, input_name=''):
            return input_data
        def gds_format_datetime(self, input_data, input_name=''):
            if input_data.microsecond == 0:
                _svalue = '%04d-%02d-%02dT%02d:%02d:%02d' % (
                    input_data.year,
                    input_data.month,
                    input_data.day,
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                )
            else:
                _svalue = '%04d-%02d-%02dT%02d:%02d:%02d.%s' % (
                    input_data.year,
                    input_data.month,
                    input_data.day,
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                    ('%f' % (float(input_data.microsecond) / 1000000))[2:],
                )
            if input_data.tzinfo is not None:
                tzoff = input_data.tzinfo.utcoffset(input_data)
                if tzoff is not None:
                    total_seconds = tzoff.seconds + (86400 * tzoff.days)
                    if total_seconds == 0:
                        _svalue += 'Z'
                    else:
                        if total_seconds < 0:
                            _svalue += '-'
                            total_seconds *= -1
                        else:
                            _svalue += '+'
                        hours = total_seconds // 3600
                        minutes = (total_seconds - (hours * 3600)) // 60
                        _svalue += '{0:02d}:{1:02d}'.format(hours, minutes)
            return _svalue
        @classmethod
        def gds_parse_datetime(cls, input_data):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'UTC')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            if len(input_data.split('.')) > 1:
                # ESPA- Remove digits from the micro seconds if there are more
                # than 6 because python datetime.strptime '%f' only supports
                # upto 6 digits
                parts = input_data.split('.')
                while len(parts[1]) > 6:
                    parts[1] = parts[1][:-1]
                input_data = '.'.join(parts)
                dt = datetime_.datetime.strptime(
                    input_data, '%Y-%m-%dT%H:%M:%S.%f')
            else:
                dt = datetime_.datetime.strptime(
                    input_data, '%Y-%m-%dT%H:%M:%S')
            dt = dt.replace(tzinfo=tz)
            return dt
        def gds_validate_date(self, input_data, node, input_name=''):
            return input_data
        def gds_format_date(self, input_data, input_name=''):
            _svalue = '%04d-%02d-%02d' % (
                input_data.year,
                input_data.month,
                input_data.day,
            )
            try:
                if input_data.tzinfo is not None:
                    tzoff = input_data.tzinfo.utcoffset(input_data)
                    if tzoff is not None:
                        total_seconds = tzoff.seconds + (86400 * tzoff.days)
                        if total_seconds == 0:
                            _svalue += 'Z'
                        else:
                            if total_seconds < 0:
                                _svalue += '-'
                                total_seconds *= -1
                            else:
                                _svalue += '+'
                            hours = total_seconds // 3600
                            minutes = (total_seconds - (hours * 3600)) // 60
                            _svalue += '{0:02d}:{1:02d}'.format(hours, minutes)
            except AttributeError:
                pass
            return _svalue
        @classmethod
        def gds_parse_date(cls, input_data):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'UTC')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            dt = datetime_.datetime.strptime(input_data, '%Y-%m-%d')
            dt = dt.replace(tzinfo=tz)
            return dt.date()
        def gds_validate_time(self, input_data, node, input_name=''):
            return input_data
        def gds_format_time(self, input_data, input_name=''):
            if input_data.microsecond == 0:
                _svalue = '%02d:%02d:%02d' % (
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                )
            else:
                # ESPA - We output a Z with this time so added it
                _svalue = '%02d:%02d:%02d.%sZ' % (
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                    ('%f' % (float(input_data.microsecond) / 1000000))[2:],
                )
            if input_data.tzinfo is not None:
                tzoff = input_data.tzinfo.utcoffset(input_data)
                if tzoff is not None:
                    total_seconds = tzoff.seconds + (86400 * tzoff.days)
                    if total_seconds == 0:
                        _svalue += 'Z'
                    else:
                        if total_seconds < 0:
                            _svalue += '-'
                            total_seconds *= -1
                        else:
                            _svalue += '+'
                        hours = total_seconds // 3600
                        minutes = (total_seconds - (hours * 3600)) // 60
                        _svalue += '{0:02d}:{1:02d}'.format(hours, minutes)
            return _svalue
        @classmethod
        def gds_parse_time(cls, input_data):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'UTC')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            if len(input_data.split('.')) > 1:
                # ESPA- Remove digits from the micro seconds if there are more
                # than 6 because python datetime.strptime '%f' only supports
                # upto 6 digits
                parts = input_data.split('.')
                while len(parts[1]) > 6:
                    parts[1] = parts[1][:-1]
                input_data = '.'.join(parts)
                dt = datetime_.datetime.strptime(input_data, '%H:%M:%S.%f')
            else:
                dt = datetime_.datetime.strptime(input_data, '%H:%M:%S')
            dt = dt.replace(tzinfo=tz)
            return dt.time()
        def gds_str_lower(self, instring):
            return instring.lower()
        def get_path_(self, node):
            path_list = []
            self.get_path_list_(node, path_list)
            path_list.reverse()
            path = '/'.join(path_list)
            return path
        Tag_strip_pattern_ = re_.compile(r'\{.*\}')
        def get_path_list_(self, node, path_list):
            if node is None:
                return
            tag = GeneratedsSuper.Tag_strip_pattern_.sub('', node.tag)
            if tag:
                path_list.append(tag)
            self.get_path_list_(node.getparent(), path_list)
        def get_class_obj_(self, node, default_class=None):
            class_obj1 = default_class
            if 'xsi' in node.nsmap:
                classname = node.get('{%s}type' % node.nsmap['xsi'])
                if classname is not None:
                    names = classname.split(':')
                    if len(names) == 2:
                        classname = names[1]
                    class_obj2 = globals().get(classname)
                    if class_obj2 is not None:
                        class_obj1 = class_obj2
            return class_obj1
        def gds_build_any(self, node, type_name=None):
            return None
        @classmethod
        def gds_reverse_node_mapping(cls, mapping):
            return dict(((v, k) for k, v in mapping.iteritems()))


#
# If you have installed IPython you can uncomment and use the following.
# IPython is available from http://ipython.scipy.org/.
#

## from IPython.Shell import IPShellEmbed
## args = ''
## ipshell = IPShellEmbed(args,
##     banner = 'Dropping into IPython',
##     exit_msg = 'Leaving Interpreter, back to program.')

# Then use the following line where and when you want to drop into the
# IPython shell:
#    ipshell('<some message> -- Entering ipshell.\nHit Ctrl-D to exit')

#
# Globals
#

ExternalEncoding = 'UTF-8'
Tag_pattern_ = re_.compile(r'({.*})?(.*)')
String_cleanup_pat_ = re_.compile(r"[\n\r\s]+")
Namespace_extract_pat_ = re_.compile(r'{(.*)}(.*)')

#
# Support/utility functions.
#


def showIndent(outfile, level, pretty_print=True):
    if pretty_print:
        for idx in range(level):
            outfile.write('    ')


def quote_xml(inStr):
    if not inStr:
        return ''
    s1 = (isinstance(inStr, basestring) and inStr or
          '%s' % inStr)
    s1 = s1.replace('&', '&amp;')
    s1 = s1.replace('<', '&lt;')
    s1 = s1.replace('>', '&gt;')
    return s1


def quote_attrib(inStr):
    s1 = (isinstance(inStr, basestring) and inStr or
          '%s' % inStr)
    s1 = s1.replace('&', '&amp;')
    s1 = s1.replace('<', '&lt;')
    s1 = s1.replace('>', '&gt;')
    if '"' in s1:
        if "'" in s1:
            s1 = '"%s"' % s1.replace('"', "&quot;")
        else:
            s1 = "'%s'" % s1
    else:
        s1 = '"%s"' % s1
    return s1


def quote_python(inStr):
    s1 = inStr
    if s1.find("'") == -1:
        if s1.find('\n') == -1:
            return "'%s'" % s1
        else:
            return "'''%s'''" % s1
    else:
        if s1.find('"') != -1:
            s1 = s1.replace('"', '\\"')
        if s1.find('\n') == -1:
            return '"%s"' % s1
        else:
            return '"""%s"""' % s1


def get_all_text_(node):
    if node.text is not None:
        text = node.text
    else:
        text = ''
    for child in node:
        if child.tail is not None:
            text += child.tail
    return text


def find_attr_value_(attr_name, node):
    attrs = node.attrib
    attr_parts = attr_name.split(':')
    value = None
    if len(attr_parts) == 1:
        value = attrs.get(attr_name)
    elif len(attr_parts) == 2:
        prefix, name = attr_parts
        namespace = node.nsmap.get(prefix)
        if namespace is not None:
            value = attrs.get('{%s}%s' % (namespace, name, ))
    return value


class GDSParseError(Exception):
    pass


def raise_parse_error(node, msg):
    if XMLParser_import_library == XMLParser_import_lxml:
        msg = '%s (element %s/line %d)' % (
            msg, node.tag, node.sourceline, )
    else:
        msg = '%s (element %s)' % (msg, node.tag, )
    raise GDSParseError(msg)


class MixedContainer:
    # Constants for category:
    CategoryNone = 0
    CategoryText = 1
    CategorySimple = 2
    CategoryComplex = 3
    # Constants for content_type:
    TypeNone = 0
    TypeText = 1
    TypeString = 2
    TypeInteger = 3
    TypeFloat = 4
    TypeDecimal = 5
    TypeDouble = 6
    TypeBoolean = 7
    TypeBase64 = 8
    def __init__(self, category, content_type, name, value):
        self.category = category
        self.content_type = content_type
        self.name = name
        self.value = value
    def getCategory(self):
        return self.category
    def getContenttype(self, content_type):
        return self.content_type
    def getValue(self):
        return self.value
    def getName(self):
        return self.name
    def export(self, outfile, level, name, namespace, pretty_print=True):
        if self.category == MixedContainer.CategoryText:
            # Prevent exporting empty content as empty lines.
            if self.value.strip():
                outfile.write(self.value)
        elif self.category == MixedContainer.CategorySimple:
            self.exportSimple(outfile, level, name)
        else:    # category == MixedContainer.CategoryComplex
            self.value.export(outfile, level, namespace, name, pretty_print)
    def exportSimple(self, outfile, level, name):
        if self.content_type == MixedContainer.TypeString:
            outfile.write('<%s>%s</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeInteger or \
                self.content_type == MixedContainer.TypeBoolean:
            outfile.write('<%s>%d</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeFloat or \
                self.content_type == MixedContainer.TypeDecimal:
            outfile.write('<%s>%f</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeDouble:
            outfile.write('<%s>%g</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeBase64:
            outfile.write('<%s>%s</%s>' % (
                self.name, base64.b64encode(self.value), self.name))
    def to_etree(self, element):
        if self.category == MixedContainer.CategoryText:
            # Prevent exporting empty content as empty lines.
            if self.value.strip():
                if len(element) > 0:
                    if element[-1].tail is None:
                        element[-1].tail = self.value
                    else:
                        element[-1].tail += self.value
                else:
                    if element.text is None:
                        element.text = self.value
                    else:
                        element.text += self.value
        elif self.category == MixedContainer.CategorySimple:
            subelement = etree_.SubElement(element, '%s' % self.name)
            subelement.text = self.to_etree_simple()
        else:    # category == MixedContainer.CategoryComplex
            self.value.to_etree(element)
    def to_etree_simple(self):
        if self.content_type == MixedContainer.TypeString:
            text = self.value
        elif (self.content_type == MixedContainer.TypeInteger or
                self.content_type == MixedContainer.TypeBoolean):
            text = '%d' % self.value
        elif (self.content_type == MixedContainer.TypeFloat or
                self.content_type == MixedContainer.TypeDecimal):
            text = '%f' % self.value
        elif self.content_type == MixedContainer.TypeDouble:
            text = '%g' % self.value
        elif self.content_type == MixedContainer.TypeBase64:
            text = '%s' % base64.b64encode(self.value)
        return text
    def exportLiteral(self, outfile, level, name):
        if self.category == MixedContainer.CategoryText:
            showIndent(outfile, level)
            outfile.write(
                'model_.MixedContainer(%d, %d, "%s", "%s"),\n' % (
                    self.category, self.content_type, self.name, self.value))
        elif self.category == MixedContainer.CategorySimple:
            showIndent(outfile, level)
            outfile.write(
                'model_.MixedContainer(%d, %d, "%s", "%s"),\n' % (
                    self.category, self.content_type, self.name, self.value))
        else:    # category == MixedContainer.CategoryComplex
            showIndent(outfile, level)
            outfile.write(
                'model_.MixedContainer(%d, %d, "%s",\n' % (
                    self.category, self.content_type, self.name,))
            self.value.exportLiteral(outfile, level + 1)
            showIndent(outfile, level)
            outfile.write(')\n')


class MemberSpec_(object):
    def __init__(self, name='', data_type='', container=0):
        self.name = name
        self.data_type = data_type
        self.container = container
    def set_name(self, name): self.name = name
    def get_name(self): return self.name
    def set_data_type(self, data_type): self.data_type = data_type
    def get_data_type_chain(self): return self.data_type
    def get_data_type(self):
        if isinstance(self.data_type, list):
            if len(self.data_type) > 0:
                return self.data_type[-1]
            else:
                return 'xs:string'
        else:
            return self.data_type
    def set_container(self, container): self.container = container
    def get_container(self): return self.container


def _cast(typ, value):
    if typ is None or value is None:
        return value
    return typ(value)

#
# Data representation classes.
#


class corner(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, location=None, latitude=None, longitude=None):
        self.location = _cast(None, location)
        self.latitude = _cast(float, latitude)
        self.longitude = _cast(float, longitude)
        pass
    def factory(*args_, **kwargs_):
        if corner.subclass:
            return corner.subclass(*args_, **kwargs_)
        else:
            return corner(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_location(self): return self.location
    def set_location(self, location): self.location = location
    def get_latitude(self): return self.latitude
    def set_latitude(self, latitude): self.latitude = latitude
    def get_longitude(self): return self.longitude
    def set_longitude(self, longitude): self.longitude = longitude
    def validate_cornerType(self, value):
        # Validate type cornerType, a restriction on xs:string.
        pass
    def validate_latAngleType(self, value):
        # Validate type latAngleType, a restriction on xs:float.
        pass
    def validate_longAngleType(self, value):
        # Validate type longAngleType, a restriction on xs:float.
        pass
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='corner', namespacedef_='', pretty_print=True):
        # Check if we are at the root level and output the XML header
        if level == 0:
            outfile.write('<?xml version="1.0" encoding="%s"?>\n' % ExternalEncoding)
            outfile.write('\n')
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        # Check if we are at the root level and output attributes first before namespacedef
        if level == 0:
            outfile.write('<%s%s' % (namespace_, name_))
            already_processed = set()
            self.exportAttributes(outfile, level, already_processed, namespace_, name_='corner')
            outfile.write('%s' % (namespacedef_ and ' ' + namespacedef_ or ''))
        else:
            outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
            already_processed = set()
            self.exportAttributes(outfile, level, already_processed, namespace_, name_='corner')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='corner', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='corner'):
        if self.location is not None and 'location' not in already_processed:
            already_processed.add('location')
            outfile.write(' location=%s' % (quote_attrib(self.location), ))
        if self.latitude is not None and 'latitude' not in already_processed:
            already_processed.add('latitude')
            outfile.write(' latitude="%s"' % self.gds_format_float(self.latitude, input_name='latitude'))
        if self.longitude is not None and 'longitude' not in already_processed:
            already_processed.add('longitude')
            outfile.write(' longitude="%s"' % self.gds_format_float(self.longitude, input_name='longitude'))
    def exportChildren(self, outfile, level, namespace_='', name_='corner', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='corner'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.location is not None and 'location' not in already_processed:
            already_processed.add('location')
            showIndent(outfile, level)
            outfile.write('location="%s",\n' % (self.location,))
        if self.latitude is not None and 'latitude' not in already_processed:
            already_processed.add('latitude')
            showIndent(outfile, level)
            outfile.write('latitude=%f,\n' % (self.latitude,))
        if self.longitude is not None and 'longitude' not in already_processed:
            already_processed.add('longitude')
            showIndent(outfile, level)
            outfile.write('longitude=%f,\n' % (self.longitude,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('location', node)
        if value is not None and 'location' not in already_processed:
            already_processed.add('location')
            self.location = value
            self.validate_cornerType(self.location)    # validate type cornerType
        value = find_attr_value_('latitude', node)
        if value is not None and 'latitude' not in already_processed:
            already_processed.add('latitude')
            try:
                self.latitude = float(value)
            except ValueError, exp:
                raise ValueError('Bad float/double attribute (latitude): %s' % exp)
            self.validate_latAngleType(self.latitude)    # validate type latAngleType
        value = find_attr_value_('longitude', node)
        if value is not None and 'longitude' not in already_processed:
            already_processed.add('longitude')
            try:
                self.longitude = float(value)
            except ValueError, exp:
                raise ValueError('Bad float/double attribute (longitude): %s' % exp)
            self.validate_longAngleType(self.longitude)    # validate type longAngleType
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class corner


class bounding_coordinates(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, west=None, east=None, north=None, south=None):
        self.west = west
        self.east = east
        self.north = north
        self.south = south
    def factory(*args_, **kwargs_):
        if bounding_coordinates.subclass:
            return bounding_coordinates.subclass(*args_, **kwargs_)
        else:
            return bounding_coordinates(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_west(self): return self.west
    def set_west(self, west): self.west = west
    def get_east(self): return self.east
    def set_east(self, east): self.east = east
    def get_north(self): return self.north
    def set_north(self, north): self.north = north
    def get_south(self): return self.south
    def set_south(self, south): self.south = south
    def hasContent_(self):
        if (
            self.west is not None or
            self.east is not None or
            self.north is not None or
            self.south is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='bounding_coordinates', namespacedef_='', pretty_print=True):
        # Check if we are at the root level and output the XML header
        if level == 0:
            outfile.write('<?xml version="1.0" encoding="%s"?>\n' % ExternalEncoding)
            outfile.write('\n')
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        # Check if we are at the root level and output attributes first before namespacedef
        if level == 0:
            outfile.write('<%s%s' % (namespace_, name_))
            already_processed = set()
            self.exportAttributes(outfile, level, already_processed, namespace_, name_='bounding_coordinates')
            outfile.write('%s' % (namespacedef_ and ' ' + namespacedef_ or ''))
        else:
            outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
            already_processed = set()
            self.exportAttributes(outfile, level, already_processed, namespace_, name_='bounding_coordinates')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='bounding_coordinates', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='bounding_coordinates'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='bounding_coordinates', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.west is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%swest>%s</%swest>%s' % (namespace_, self.gds_format_float(self.west, input_name='west'), namespace_, eol_))
        if self.east is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%seast>%s</%seast>%s' % (namespace_, self.gds_format_float(self.east, input_name='east'), namespace_, eol_))
        if self.north is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%snorth>%s</%snorth>%s' % (namespace_, self.gds_format_float(self.north, input_name='north'), namespace_, eol_))
        if self.south is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%ssouth>%s</%ssouth>%s' % (namespace_, self.gds_format_float(self.south, input_name='south'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='bounding_coordinates'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.west is not None:
            showIndent(outfile, level)
            outfile.write('west=%f,\n' % self.west)
        if self.east is not None:
            showIndent(outfile, level)
            outfile.write('east=%f,\n' % self.east)
        if self.north is not None:
            showIndent(outfile, level)
            outfile.write('north=%f,\n' % self.north)
        if self.south is not None:
            showIndent(outfile, level)
            outfile.write('south=%f,\n' % self.south)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'west':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'west')
            self.west = fval_
        elif nodeName_ == 'east':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'east')
            self.east = fval_
        elif nodeName_ == 'north':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'north')
            self.north = fval_
        elif nodeName_ == 'south':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'south')
            self.south = fval_
# end class bounding_coordinates


class corner_point(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, location=None, x=None, y=None):
        self.location = _cast(None, location)
        self.x = _cast(float, x)
        self.y = _cast(float, y)
        pass
    def factory(*args_, **kwargs_):
        if corner_point.subclass:
            return corner_point.subclass(*args_, **kwargs_)
        else:
            return corner_point(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_location(self): return self.location
    def set_location(self, location): self.location = location
    def get_x(self): return self.x
    def set_x(self, x): self.x = x
    def get_y(self): return self.y
    def set_y(self, y): self.y = y
    def validate_cornerType(self, value):
        # Validate type cornerType, a restriction on xs:string.
        pass
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='corner_point', namespacedef_='', pretty_print=True):
        # Check if we are at the root level and output the XML header
        if level == 0:
            outfile.write('<?xml version="1.0" encoding="%s"?>\n' % ExternalEncoding)
            outfile.write('\n')
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        # Check if we are at the root level and output attributes first before namespacedef
        if level == 0:
            outfile.write('<%s%s' % (namespace_, name_))
            already_processed = set()
            self.exportAttributes(outfile, level, already_processed, namespace_, name_='corner_point')
            outfile.write('%s' % (namespacedef_ and ' ' + namespacedef_ or ''))
        else:
            outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
            already_processed = set()
            self.exportAttributes(outfile, level, already_processed, namespace_, name_='corner_point')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='corner_point', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='corner_point'):
        if self.location is not None and 'location' not in already_processed:
            already_processed.add('location')
            outfile.write(' location=%s' % (quote_attrib(self.location), ))
        if self.x is not None and 'x' not in already_processed:
            already_processed.add('x')
            outfile.write(' x="%s"' % self.gds_format_double(self.x, input_name='x'))
        if self.y is not None and 'y' not in already_processed:
            already_processed.add('y')
            outfile.write(' y="%s"' % self.gds_format_double(self.y, input_name='y'))
    def exportChildren(self, outfile, level, namespace_='', name_='corner_point', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='corner_point'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.location is not None and 'location' not in already_processed:
            already_processed.add('location')
            showIndent(outfile, level)
            outfile.write('location="%s",\n' % (self.location,))
        if self.x is not None and 'x' not in already_processed:
            already_processed.add('x')
            showIndent(outfile, level)
            outfile.write('x=%e,\n' % (self.x,))
        if self.y is not None and 'y' not in already_processed:
            already_processed.add('y')
            showIndent(outfile, level)
            outfile.write('y=%e,\n' % (self.y,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('location', node)
        if value is not None and 'location' not in already_processed:
            already_processed.add('location')
            self.location = value
            self.validate_cornerType(self.location)    # validate type cornerType
        value = find_attr_value_('x', node)
        if value is not None and 'x' not in already_processed:
            already_processed.add('x')
            try:
                self.x = float(value)
            except ValueError, exp:
                raise ValueError('Bad float/double attribute (x): %s' % exp)
        value = find_attr_value_('y', node)
        if value is not None and 'y' not in already_processed:
            already_processed.add('y')
            try:
                self.y = float(value)
            except ValueError, exp:
                raise ValueError('Bad float/double attribute (y): %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class corner_point


class utm_proj_params(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, zone_code=None):
        self.zone_code = zone_code
    def factory(*args_, **kwargs_):
        if utm_proj_params.subclass:
            return utm_proj_params.subclass(*args_, **kwargs_)
        else:
            return utm_proj_params(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_zone_code(self): return self.zone_code
    def set_zone_code(self, zone_code): self.zone_code = zone_code
    def hasContent_(self):
        if (
            self.zone_code is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='utm_proj_params', namespacedef_='', pretty_print=True):
        # Check if we are at the root level and output the XML header
        if level == 0:
            outfile.write('<?xml version="1.0" encoding="%s"?>\n' % ExternalEncoding)
            outfile.write('\n')
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        # Check if we are at the root level and output attributes first before namespacedef
        if level == 0:
            outfile.write('<%s%s' % (namespace_, name_))
            already_processed = set()
            self.exportAttributes(outfile, level, already_processed, namespace_, name_='utm_proj_params')
            outfile.write('%s' % (namespacedef_ and ' ' + namespacedef_ or ''))
        else:
            outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
            already_processed = set()
            self.exportAttributes(outfile, level, already_processed, namespace_, name_='utm_proj_params')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='utm_proj_params', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='utm_proj_params'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='utm_proj_params', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.zone_code is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%szone_code>%s</%szone_code>%s' % (namespace_, self.gds_format_integer(self.zone_code, input_name='zone_code'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='utm_proj_params'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.zone_code is not None:
            showIndent(outfile, level)
            outfile.write('zone_code=%d,\n' % self.zone_code)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'zone_code':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'zone_code')
            self.zone_code = ival_
# end class utm_proj_params


class ps_proj_params(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, longitude_pole=None, latitude_true_scale=None, false_easting=None, false_northing=None):
        self.longitude_pole = longitude_pole
        self.latitude_true_scale = latitude_true_scale
        self.false_easting = false_easting
        self.false_northing = false_northing
    def factory(*args_, **kwargs_):
        if ps_proj_params.subclass:
            return ps_proj_params.subclass(*args_, **kwargs_)
        else:
            return ps_proj_params(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_longitude_pole(self): return self.longitude_pole
    def set_longitude_pole(self, longitude_pole): self.longitude_pole = longitude_pole
    def get_latitude_true_scale(self): return self.latitude_true_scale
    def set_latitude_true_scale(self, latitude_true_scale): self.latitude_true_scale = latitude_true_scale
    def get_false_easting(self): return self.false_easting
    def set_false_easting(self, false_easting): self.false_easting = false_easting
    def get_false_northing(self): return self.false_northing
    def set_false_northing(self, false_northing): self.false_northing = false_northing
    def hasContent_(self):
        if (
            self.longitude_pole is not None or
            self.latitude_true_scale is not None or
            self.false_easting is not None or
            self.false_northing is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ps_proj_params', namespacedef_='', pretty_print=True):
        # Check if we are at the root level and output the XML header
        if level == 0:
            outfile.write('<?xml version="1.0" encoding="%s"?>\n' % ExternalEncoding)
            outfile.write('\n')
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        # Check if we are at the root level and output attributes first before namespacedef
        if level == 0:
            outfile.write('<%s%s' % (namespace_, name_))
            already_processed = set()
            self.exportAttributes(outfile, level, already_processed, namespace_, name_='ps_proj_params')
            outfile.write('%s' % (namespacedef_ and ' ' + namespacedef_ or ''))
        else:
            outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
            already_processed = set()
            self.exportAttributes(outfile, level, already_processed, namespace_, name_='ps_proj_params')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ps_proj_params', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ps_proj_params'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='ps_proj_params', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.longitude_pole is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%slongitude_pole>%s</%slongitude_pole>%s' % (namespace_, self.gds_format_float(self.longitude_pole, input_name='longitude_pole'), namespace_, eol_))
        if self.latitude_true_scale is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%slatitude_true_scale>%s</%slatitude_true_scale>%s' % (namespace_, self.gds_format_float(self.latitude_true_scale, input_name='latitude_true_scale'), namespace_, eol_))
        if self.false_easting is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sfalse_easting>%s</%sfalse_easting>%s' % (namespace_, self.gds_format_double(self.false_easting, input_name='false_easting'), namespace_, eol_))
        if self.false_northing is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sfalse_northing>%s</%sfalse_northing>%s' % (namespace_, self.gds_format_double(self.false_northing, input_name='false_northing'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='ps_proj_params'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.longitude_pole is not None:
            showIndent(outfile, level)
            outfile.write('longitude_pole=%f,\n' % self.longitude_pole)
        if self.latitude_true_scale is not None:
            showIndent(outfile, level)
            outfile.write('latitude_true_scale=%f,\n' % self.latitude_true_scale)
        if self.false_easting is not None:
            showIndent(outfile, level)
            outfile.write('false_easting=%e,\n' % self.false_easting)
        if self.false_northing is not None:
            showIndent(outfile, level)
            outfile.write('false_northing=%e,\n' % self.false_northing)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'longitude_pole':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'longitude_pole')
            self.longitude_pole = fval_
        elif nodeName_ == 'latitude_true_scale':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'latitude_true_scale')
            self.latitude_true_scale = fval_
        elif nodeName_ == 'false_easting':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'false_easting')
            self.false_easting = fval_
        elif nodeName_ == 'false_northing':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'false_northing')
            self.false_northing = fval_
# end class ps_proj_params


class albers_proj_params(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, standard_parallel1=None, standard_parallel2=None, central_meridian=None, origin_latitude=None, false_easting=None, false_northing=None):
        self.standard_parallel1 = standard_parallel1
        self.standard_parallel2 = standard_parallel2
        self.central_meridian = central_meridian
        self.origin_latitude = origin_latitude
        self.false_easting = false_easting
        self.false_northing = false_northing
    def factory(*args_, **kwargs_):
        if albers_proj_params.subclass:
            return albers_proj_params.subclass(*args_, **kwargs_)
        else:
            return albers_proj_params(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_standard_parallel1(self): return self.standard_parallel1
    def set_standard_parallel1(self, standard_parallel1): self.standard_parallel1 = standard_parallel1
    def get_standard_parallel2(self): return self.standard_parallel2
    def set_standard_parallel2(self, standard_parallel2): self.standard_parallel2 = standard_parallel2
    def get_central_meridian(self): return self.central_meridian
    def set_central_meridian(self, central_meridian): self.central_meridian = central_meridian
    def get_origin_latitude(self): return self.origin_latitude
    def set_origin_latitude(self, origin_latitude): self.origin_latitude = origin_latitude
    def get_false_easting(self): return self.false_easting
    def set_false_easting(self, false_easting): self.false_easting = false_easting
    def get_false_northing(self): return self.false_northing
    def set_false_northing(self, false_northing): self.false_northing = false_northing
    def hasContent_(self):
        if (
            self.standard_parallel1 is not None or
            self.standard_parallel2 is not None or
            self.central_meridian is not None or
            self.origin_latitude is not None or
            self.false_easting is not None or
            self.false_northing is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='albers_proj_params', namespacedef_='', pretty_print=True):
        # Check if we are at the root level and output the XML header
        if level == 0:
            outfile.write('<?xml version="1.0" encoding="%s"?>\n' % ExternalEncoding)
            outfile.write('\n')
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        # Check if we are at the root level and output attributes first before namespacedef
        if level == 0:
            outfile.write('<%s%s' % (namespace_, name_))
            already_processed = set()
            self.exportAttributes(outfile, level, already_processed, namespace_, name_='albers_proj_params')
            outfile.write('%s' % (namespacedef_ and ' ' + namespacedef_ or ''))
        else:
            outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
            already_processed = set()
            self.exportAttributes(outfile, level, already_processed, namespace_, name_='albers_proj_params')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='albers_proj_params', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='albers_proj_params'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='albers_proj_params', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.standard_parallel1 is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sstandard_parallel1>%s</%sstandard_parallel1>%s' % (namespace_, self.gds_format_float(self.standard_parallel1, input_name='standard_parallel1'), namespace_, eol_))
        if self.standard_parallel2 is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sstandard_parallel2>%s</%sstandard_parallel2>%s' % (namespace_, self.gds_format_float(self.standard_parallel2, input_name='standard_parallel2'), namespace_, eol_))
        if self.central_meridian is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scentral_meridian>%s</%scentral_meridian>%s' % (namespace_, self.gds_format_float(self.central_meridian, input_name='central_meridian'), namespace_, eol_))
        if self.origin_latitude is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sorigin_latitude>%s</%sorigin_latitude>%s' % (namespace_, self.gds_format_float(self.origin_latitude, input_name='origin_latitude'), namespace_, eol_))
        if self.false_easting is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sfalse_easting>%s</%sfalse_easting>%s' % (namespace_, self.gds_format_double(self.false_easting, input_name='false_easting'), namespace_, eol_))
        if self.false_northing is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sfalse_northing>%s</%sfalse_northing>%s' % (namespace_, self.gds_format_double(self.false_northing, input_name='false_northing'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='albers_proj_params'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.standard_parallel1 is not None:
            showIndent(outfile, level)
            outfile.write('standard_parallel1=%f,\n' % self.standard_parallel1)
        if self.standard_parallel2 is not None:
            showIndent(outfile, level)
            outfile.write('standard_parallel2=%f,\n' % self.standard_parallel2)
        if self.central_meridian is not None:
            showIndent(outfile, level)
            outfile.write('central_meridian=%f,\n' % self.central_meridian)
        if self.origin_latitude is not None:
            showIndent(outfile, level)
            outfile.write('origin_latitude=%f,\n' % self.origin_latitude)
        if self.false_easting is not None:
            showIndent(outfile, level)
            outfile.write('false_easting=%e,\n' % self.false_easting)
        if self.false_northing is not None:
            showIndent(outfile, level)
            outfile.write('false_northing=%e,\n' % self.false_northing)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'standard_parallel1':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'standard_parallel1')
            self.standard_parallel1 = fval_
        elif nodeName_ == 'standard_parallel2':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'standard_parallel2')
            self.standard_parallel2 = fval_
        elif nodeName_ == 'central_meridian':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'central_meridian')
            self.central_meridian = fval_
        elif nodeName_ == 'origin_latitude':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'origin_latitude')
            self.origin_latitude = fval_
        elif nodeName_ == 'false_easting':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'false_easting')
            self.false_easting = fval_
        elif nodeName_ == 'false_northing':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'false_northing')
            self.false_northing = fval_
# end class albers_proj_params


class projection_information(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, projection=None, sphere_code=None, units=None, corner_point=None, grid_origin=None, utm_proj_params=None, ps_proj_params=None, albers_proj_params=None):
        self.projection = _cast(None, projection)
        self.sphere_code = _cast(int, sphere_code)
        self.units = _cast(None, units)
        if corner_point is None:
            self.corner_point = []
        else:
            self.corner_point = corner_point
        self.grid_origin = grid_origin
        self.utm_proj_params = utm_proj_params
        self.ps_proj_params = ps_proj_params
        self.albers_proj_params = albers_proj_params
    def factory(*args_, **kwargs_):
        if projection_information.subclass:
            return projection_information.subclass(*args_, **kwargs_)
        else:
            return projection_information(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_corner_point(self): return self.corner_point
    def set_corner_point(self, corner_point): self.corner_point = corner_point
    def add_corner_point(self, value): self.corner_point.append(value)
    def insert_corner_point(self, index, value): self.corner_point[index] = value
    def get_grid_origin(self): return self.grid_origin
    def set_grid_origin(self, grid_origin): self.grid_origin = grid_origin
    def get_utm_proj_params(self): return self.utm_proj_params
    def set_utm_proj_params(self, utm_proj_params): self.utm_proj_params = utm_proj_params
    def get_ps_proj_params(self): return self.ps_proj_params
    def set_ps_proj_params(self, ps_proj_params): self.ps_proj_params = ps_proj_params
    def get_albers_proj_params(self): return self.albers_proj_params
    def set_albers_proj_params(self, albers_proj_params): self.albers_proj_params = albers_proj_params
    def get_projection(self): return self.projection
    def set_projection(self, projection): self.projection = projection
    def get_sphere_code(self): return self.sphere_code
    def set_sphere_code(self, sphere_code): self.sphere_code = sphere_code
    def get_units(self): return self.units
    def set_units(self, units): self.units = units
    def validate_projectionType(self, value):
        # Validate type projectionType, a restriction on xs:string.
        pass
    def validate_projectionUnitsType(self, value):
        # Validate type projectionUnitsType, a restriction on xs:string.
        pass
    def hasContent_(self):
        if (
            self.corner_point or
            self.grid_origin is not None or
            self.utm_proj_params is not None or
            self.ps_proj_params is not None or
            self.albers_proj_params is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='projection_information', namespacedef_='', pretty_print=True):
        # Check if we are at the root level and output the XML header
        if level == 0:
            outfile.write('<?xml version="1.0" encoding="%s"?>\n' % ExternalEncoding)
            outfile.write('\n')
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        # Check if we are at the root level and output attributes first before namespacedef
        if level == 0:
            outfile.write('<%s%s' % (namespace_, name_))
            already_processed = set()
            self.exportAttributes(outfile, level, already_processed, namespace_, name_='projection_information')
            outfile.write('%s' % (namespacedef_ and ' ' + namespacedef_ or ''))
        else:
            outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
            already_processed = set()
            self.exportAttributes(outfile, level, already_processed, namespace_, name_='projection_information')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='projection_information', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='projection_information'):
        if self.projection is not None and 'projection' not in already_processed:
            already_processed.add('projection')
            outfile.write(' projection=%s' % (quote_attrib(self.projection), ))
        if self.sphere_code is not None and 'sphere_code' not in already_processed:
            already_processed.add('sphere_code')
            outfile.write(' sphere_code="%s"' % self.gds_format_integer(self.sphere_code, input_name='sphere_code'))
        if self.units is not None and 'units' not in already_processed:
            already_processed.add('units')
            outfile.write(' units=%s' % (quote_attrib(self.units), ))
    def exportChildren(self, outfile, level, namespace_='', name_='projection_information', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for corner_point_ in self.corner_point:
            corner_point_.export(outfile, level, namespace_, name_='corner_point', pretty_print=pretty_print)
        if self.grid_origin is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sgrid_origin>%s</%sgrid_origin>%s' % (namespace_, self.gds_format_string(quote_xml(self.grid_origin).encode(ExternalEncoding), input_name='grid_origin'), namespace_, eol_))
        if self.utm_proj_params is not None:
            self.utm_proj_params.export(outfile, level, namespace_, name_='utm_proj_params', pretty_print=pretty_print)
        if self.ps_proj_params is not None:
            self.ps_proj_params.export(outfile, level, namespace_, name_='ps_proj_params', pretty_print=pretty_print)
        if self.albers_proj_params is not None:
            self.albers_proj_params.export(outfile, level, namespace_, name_='albers_proj_params', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='projection_information'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.projection is not None and 'projection' not in already_processed:
            already_processed.add('projection')
            showIndent(outfile, level)
            outfile.write('projection="%s",\n' % (self.projection,))
        if self.sphere_code is not None and 'sphere_code' not in already_processed:
            already_processed.add('sphere_code')
            showIndent(outfile, level)
            outfile.write('sphere_code=%d,\n' % (self.sphere_code,))
        if self.units is not None and 'units' not in already_processed:
            already_processed.add('units')
            showIndent(outfile, level)
            outfile.write('units="%s",\n' % (self.units,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('corner_point=[\n')
        level += 1
        for corner_point_ in self.corner_point:
            showIndent(outfile, level)
            outfile.write('model_.corner_point(\n')
            corner_point_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.grid_origin is not None:
            showIndent(outfile, level)
            outfile.write('grid_origin=%s,\n' % quote_python(self.grid_origin).encode(ExternalEncoding))
        if self.utm_proj_params is not None:
            showIndent(outfile, level)
            outfile.write('utm_proj_params=model_.utm_proj_params(\n')
            self.utm_proj_params.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.ps_proj_params is not None:
            showIndent(outfile, level)
            outfile.write('ps_proj_params=model_.ps_proj_params(\n')
            self.ps_proj_params.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.albers_proj_params is not None:
            showIndent(outfile, level)
            outfile.write('albers_proj_params=model_.albers_proj_params(\n')
            self.albers_proj_params.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('projection', node)
        if value is not None and 'projection' not in already_processed:
            already_processed.add('projection')
            self.projection = value
            self.validate_projectionType(self.projection)    # validate type projectionType
        value = find_attr_value_('sphere_code', node)
        if value is not None and 'sphere_code' not in already_processed:
            already_processed.add('sphere_code')
            try:
                self.sphere_code = int(value)
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('units', node)
        if value is not None and 'units' not in already_processed:
            already_processed.add('units')
            self.units = value
            self.validate_projectionUnitsType(self.units)    # validate type projectionUnitsType
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'corner_point':
            obj_ = corner_point.factory()
            obj_.build(child_)
            self.corner_point.append(obj_)
        elif nodeName_ == 'grid_origin':
            grid_origin_ = child_.text
            grid_origin_ = self.gds_validate_string(grid_origin_, node, 'grid_origin')
            self.grid_origin = grid_origin_
        elif nodeName_ == 'utm_proj_params':
            obj_ = utm_proj_params.factory()
            obj_.build(child_)
            self.utm_proj_params = obj_
        elif nodeName_ == 'ps_proj_params':
            obj_ = ps_proj_params.factory()
            obj_.build(child_)
            self.ps_proj_params = obj_
        elif nodeName_ == 'albers_proj_params':
            obj_ = albers_proj_params.factory()
            obj_.build(child_)
            self.albers_proj_params = obj_
# end class projection_information


class pixel_size(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, x=None, y=None, units=None):
        self.x = _cast(float, x)
        self.y = _cast(float, y)
        self.units = _cast(None, units)
        pass
    def factory(*args_, **kwargs_):
        if pixel_size.subclass:
            return pixel_size.subclass(*args_, **kwargs_)
        else:
            return pixel_size(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_x(self): return self.x
    def set_x(self, x): self.x = x
    def get_y(self): return self.y
    def set_y(self, y): self.y = y
    def get_units(self): return self.units
    def set_units(self, units): self.units = units
    def validate_projectionUnitsType(self, value):
        # Validate type projectionUnitsType, a restriction on xs:string.
        pass
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='pixel_size', namespacedef_='', pretty_print=True):
        # Check if we are at the root level and output the XML header
        if level == 0:
            outfile.write('<?xml version="1.0" encoding="%s"?>\n' % ExternalEncoding)
            outfile.write('\n')
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        # Check if we are at the root level and output attributes first before namespacedef
        if level == 0:
            outfile.write('<%s%s' % (namespace_, name_))
            already_processed = set()
            self.exportAttributes(outfile, level, already_processed, namespace_, name_='pixel_size')
            outfile.write('%s' % (namespacedef_ and ' ' + namespacedef_ or ''))
        else:
            outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
            already_processed = set()
            self.exportAttributes(outfile, level, already_processed, namespace_, name_='pixel_size')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='pixel_size', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='pixel_size'):
        if self.x is not None and 'x' not in already_processed:
            already_processed.add('x')
            outfile.write(' x="%s"' % self.gds_format_double(self.x, input_name='x'))
        if self.y is not None and 'y' not in already_processed:
            already_processed.add('y')
            outfile.write(' y="%s"' % self.gds_format_double(self.y, input_name='y'))
        if self.units is not None and 'units' not in already_processed:
            already_processed.add('units')
            outfile.write(' units=%s' % (quote_attrib(self.units), ))
    def exportChildren(self, outfile, level, namespace_='', name_='pixel_size', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='pixel_size'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.x is not None and 'x' not in already_processed:
            already_processed.add('x')
            showIndent(outfile, level)
            outfile.write('x=%e,\n' % (self.x,))
        if self.y is not None and 'y' not in already_processed:
            already_processed.add('y')
            showIndent(outfile, level)
            outfile.write('y=%e,\n' % (self.y,))
        if self.units is not None and 'units' not in already_processed:
            already_processed.add('units')
            showIndent(outfile, level)
            outfile.write('units="%s",\n' % (self.units,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('x', node)
        if value is not None and 'x' not in already_processed:
            already_processed.add('x')
            try:
                self.x = float(value)
            except ValueError, exp:
                raise ValueError('Bad float/double attribute (x): %s' % exp)
        value = find_attr_value_('y', node)
        if value is not None and 'y' not in already_processed:
            already_processed.add('y')
            try:
                self.y = float(value)
            except ValueError, exp:
                raise ValueError('Bad float/double attribute (y): %s' % exp)
        value = find_attr_value_('units', node)
        if value is not None and 'units' not in already_processed:
            already_processed.add('units')
            self.units = value
            self.validate_projectionUnitsType(self.units)    # validate type projectionUnitsType
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class pixel_size


class toa_reflectance(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, gain=None, bias=None):
        self.gain = _cast(float, gain)
        self.bias = _cast(float, bias)
        pass
    def factory(*args_, **kwargs_):
        if toa_reflectance.subclass:
            return toa_reflectance.subclass(*args_, **kwargs_)
        else:
            return toa_reflectance(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_gain(self): return self.gain
    def set_gain(self, gain): self.gain = gain
    def get_bias(self): return self.bias
    def set_bias(self, bias): self.bias = bias
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='toa_reflectance', namespacedef_='', pretty_print=True):
        # Check if we are at the root level and output the XML header
        if level == 0:
            outfile.write('<?xml version="1.0" encoding="%s"?>\n' % ExternalEncoding)
            outfile.write('\n')
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        # Check if we are at the root level and output attributes first before namespacedef
        if level == 0:
            outfile.write('<%s%s' % (namespace_, name_))
            already_processed = set()
            self.exportAttributes(outfile, level, already_processed, namespace_, name_='toa_reflectance')
            outfile.write('%s' % (namespacedef_ and ' ' + namespacedef_ or ''))
        else:
            outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
            already_processed = set()
            self.exportAttributes(outfile, level, already_processed, namespace_, name_='toa_reflectance')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='toa_reflectance', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='toa_reflectance'):
        if self.gain is not None and 'gain' not in already_processed:
            already_processed.add('gain')
            outfile.write(' gain="%s"' % self.gds_format_double(self.gain, input_name='gain'))
        if self.bias is not None and 'bias' not in already_processed:
            already_processed.add('bias')
            outfile.write(' bias="%s"' % self.gds_format_double(self.bias, input_name='bias'))
    def exportChildren(self, outfile, level, namespace_='', name_='toa_reflectance', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='toa_reflectance'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.gain is not None and 'gain' not in already_processed:
            already_processed.add('gain')
            showIndent(outfile, level)
            outfile.write('gain=%e,\n' % (self.gain,))
        if self.bias is not None and 'bias' not in already_processed:
            already_processed.add('bias')
            showIndent(outfile, level)
            outfile.write('bias=%e,\n' % (self.bias,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('gain', node)
        if value is not None and 'gain' not in already_processed:
            already_processed.add('gain')
            try:
                self.gain = float(value)
            except ValueError, exp:
                raise ValueError('Bad float/double attribute (gain): %s' % exp)
        value = find_attr_value_('bias', node)
        if value is not None and 'bias' not in already_processed:
            already_processed.add('bias')
            try:
                self.bias = float(value)
            except ValueError, exp:
                raise ValueError('Bad float/double attribute (bias): %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class toa_reflectance


class solar_angles(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, zenith=None, azimuth=None, units=None):
        self.zenith = _cast(float, zenith)
        self.azimuth = _cast(float, azimuth)
        self.units = _cast(None, units)
        pass
    def factory(*args_, **kwargs_):
        if solar_angles.subclass:
            return solar_angles.subclass(*args_, **kwargs_)
        else:
            return solar_angles(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_zenith(self): return self.zenith
    def set_zenith(self, zenith): self.zenith = zenith
    def get_azimuth(self): return self.azimuth
    def set_azimuth(self, azimuth): self.azimuth = azimuth
    def get_units(self): return self.units
    def set_units(self, units): self.units = units
    def validate_angleType(self, value):
        # Validate type angleType, a restriction on xs:float.
        pass
    def validate_projectionUnitsType(self, value):
        # Validate type projectionUnitsType, a restriction on xs:string.
        pass
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='solar_angles', namespacedef_='', pretty_print=True):
        # Check if we are at the root level and output the XML header
        if level == 0:
            outfile.write('<?xml version="1.0" encoding="%s"?>\n' % ExternalEncoding)
            outfile.write('\n')
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        # Check if we are at the root level and output attributes first before namespacedef
        if level == 0:
            outfile.write('<%s%s' % (namespace_, name_))
            already_processed = set()
            self.exportAttributes(outfile, level, already_processed, namespace_, name_='solar_angles')
            outfile.write('%s' % (namespacedef_ and ' ' + namespacedef_ or ''))
        else:
            outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
            already_processed = set()
            self.exportAttributes(outfile, level, already_processed, namespace_, name_='solar_angles')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='solar_angles', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='solar_angles'):
        if self.zenith is not None and 'zenith' not in already_processed:
            already_processed.add('zenith')
            outfile.write(' zenith="%s"' % self.gds_format_float(self.zenith, input_name='zenith'))
        if self.azimuth is not None and 'azimuth' not in already_processed:
            already_processed.add('azimuth')
            outfile.write(' azimuth="%s"' % self.gds_format_float(self.azimuth, input_name='azimuth'))
        if self.units is not None and 'units' not in already_processed:
            already_processed.add('units')
            outfile.write(' units=%s' % (quote_attrib(self.units), ))
    def exportChildren(self, outfile, level, namespace_='', name_='solar_angles', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='solar_angles'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.zenith is not None and 'zenith' not in already_processed:
            already_processed.add('zenith')
            showIndent(outfile, level)
            outfile.write('zenith=%f,\n' % (self.zenith,))
        if self.azimuth is not None and 'azimuth' not in already_processed:
            already_processed.add('azimuth')
            showIndent(outfile, level)
            outfile.write('azimuth=%f,\n' % (self.azimuth,))
        if self.units is not None and 'units' not in already_processed:
            already_processed.add('units')
            showIndent(outfile, level)
            outfile.write('units="%s",\n' % (self.units,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('zenith', node)
        if value is not None and 'zenith' not in already_processed:
            already_processed.add('zenith')
            try:
                self.zenith = float(value)
            except ValueError, exp:
                raise ValueError('Bad float/double attribute (zenith): %s' % exp)
            self.validate_angleType(self.zenith)    # validate type angleType
        value = find_attr_value_('azimuth', node)
        if value is not None and 'azimuth' not in already_processed:
            already_processed.add('azimuth')
            try:
                self.azimuth = float(value)
            except ValueError, exp:
                raise ValueError('Bad float/double attribute (azimuth): %s' % exp)
            self.validate_angleType(self.azimuth)    # validate type angleType
        value = find_attr_value_('units', node)
        if value is not None and 'units' not in already_processed:
            already_processed.add('units')
            self.units = value
            self.validate_projectionUnitsType(self.units)    # validate type projectionUnitsType
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class solar_angles


class wrs(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, system=None, path=None, row=None):
        self.system = _cast(None, system)
        self.path = _cast(None, path)
        self.row = _cast(None, row)
        pass
    def factory(*args_, **kwargs_):
        if wrs.subclass:
            return wrs.subclass(*args_, **kwargs_)
        else:
            return wrs(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_system(self): return self.system
    def set_system(self, system): self.system = system
    def get_path(self): return self.path
    def set_path(self, path): self.path = path
    def get_row(self): return self.row
    def set_row(self, row): self.row = row
    def validate_wrsSystemType(self, value):
        # Validate type wrsSystemType, a restriction on xs:unsignedByte.
        pass
    def validate_wrsPathType(self, value):
        # Validate type wrsPathType, a restriction on xs:unsignedByte.
        pass
    def validate_wrsRowType(self, value):
        # Validate type wrsRowType, a restriction on xs:unsignedByte.
        pass
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='wrs', namespacedef_='', pretty_print=True):
        # Check if we are at the root level and output the XML header
        if level == 0:
            outfile.write('<?xml version="1.0" encoding="%s"?>\n' % ExternalEncoding)
            outfile.write('\n')
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        # Check if we are at the root level and output attributes first before namespacedef
        if level == 0:
            outfile.write('<%s%s' % (namespace_, name_))
            already_processed = set()
            self.exportAttributes(outfile, level, already_processed, namespace_, name_='wrs')
            outfile.write('%s' % (namespacedef_ and ' ' + namespacedef_ or ''))
        else:
            outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
            already_processed = set()
            self.exportAttributes(outfile, level, already_processed, namespace_, name_='wrs')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='wrs', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='wrs'):
        if self.system is not None and 'system' not in already_processed:
            already_processed.add('system')
            outfile.write(' system=%s' % (quote_attrib(self.system), ))
        if self.path is not None and 'path' not in already_processed:
            already_processed.add('path')
            outfile.write(' path=%s' % (quote_attrib(self.path), ))
        if self.row is not None and 'row' not in already_processed:
            already_processed.add('row')
            outfile.write(' row=%s' % (quote_attrib(self.row), ))
    def exportChildren(self, outfile, level, namespace_='', name_='wrs', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='wrs'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.system is not None and 'system' not in already_processed:
            already_processed.add('system')
            showIndent(outfile, level)
            outfile.write('system=%d,\n' % (self.system,))
        if self.path is not None and 'path' not in already_processed:
            already_processed.add('path')
            showIndent(outfile, level)
            outfile.write('path=%d,\n' % (self.path,))
        if self.row is not None and 'row' not in already_processed:
            already_processed.add('row')
            showIndent(outfile, level)
            outfile.write('row=%d,\n' % (self.row,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('system', node)
        if value is not None and 'system' not in already_processed:
            already_processed.add('system')
            try:
                self.system = int(value)
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            self.validate_wrsSystemType(self.system)    # validate type wrsSystemType
        value = find_attr_value_('path', node)
        if value is not None and 'path' not in already_processed:
            already_processed.add('path')
            try:
                self.path = int(value)
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            self.validate_wrsPathType(self.path)    # validate type wrsPathType
        value = find_attr_value_('row', node)
        if value is not None and 'row' not in already_processed:
            already_processed.add('row')
            try:
                self.row = int(value)
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            self.validate_wrsRowType(self.row)    # validate type wrsRowType
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class wrs


class valid_range(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, min=None, max=None):
        self.min = _cast(int, min)
        self.max = _cast(int, max)
        pass
    def factory(*args_, **kwargs_):
        if valid_range.subclass:
            return valid_range.subclass(*args_, **kwargs_)
        else:
            return valid_range(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_min(self): return self.min
    def set_min(self, min): self.min = min
    def get_max(self): return self.max
    def set_max(self, max): self.max = max
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='valid_range', namespacedef_='', pretty_print=True):
        # Check if we are at the root level and output the XML header
        if level == 0:
            outfile.write('<?xml version="1.0" encoding="%s"?>\n' % ExternalEncoding)
            outfile.write('\n')
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        # Check if we are at the root level and output attributes first before namespacedef
        if level == 0:
            outfile.write('<%s%s' % (namespace_, name_))
            already_processed = set()
            self.exportAttributes(outfile, level, already_processed, namespace_, name_='valid_range')
            outfile.write('%s' % (namespacedef_ and ' ' + namespacedef_ or ''))
        else:
            outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
            already_processed = set()
            self.exportAttributes(outfile, level, already_processed, namespace_, name_='valid_range')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='valid_range', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='valid_range'):
        if self.min is not None and 'min' not in already_processed:
            already_processed.add('min')
            outfile.write(' min="%s"' % self.gds_format_integer(self.min, input_name='min'))
        if self.max is not None and 'max' not in already_processed:
            already_processed.add('max')
            outfile.write(' max="%s"' % self.gds_format_integer(self.max, input_name='max'))
    def exportChildren(self, outfile, level, namespace_='', name_='valid_range', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='valid_range'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.min is not None and 'min' not in already_processed:
            already_processed.add('min')
            showIndent(outfile, level)
            outfile.write('min=%d,\n' % (self.min,))
        if self.max is not None and 'max' not in already_processed:
            already_processed.add('max')
            showIndent(outfile, level)
            outfile.write('max=%d,\n' % (self.max,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('min', node)
        if value is not None and 'min' not in already_processed:
            already_processed.add('min')
            try:
                self.min = int(value)
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('max', node)
        if value is not None and 'max' not in already_processed:
            already_processed.add('max')
            try:
                self.max = int(value)
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class valid_range


class bit(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, num=None, valueOf_=None):
        self.num = _cast(int, num)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if bit.subclass:
            return bit.subclass(*args_, **kwargs_)
        else:
            return bit(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_num(self): return self.num
    def set_num(self, num): self.num = num
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='bit', namespacedef_='', pretty_print=True):
        # Check if we are at the root level and output the XML header
        if level == 0:
            outfile.write('<?xml version="1.0" encoding="%s"?>\n' % ExternalEncoding)
            outfile.write('\n')
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        # Check if we are at the root level and output attributes first before namespacedef
        if level == 0:
            outfile.write('<%s%s' % (namespace_, name_))
            already_processed = set()
            self.exportAttributes(outfile, level, already_processed, namespace_, name_='bit')
            outfile.write('%s' % (namespacedef_ and ' ' + namespacedef_ or ''))
        else:
            outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
            already_processed = set()
            self.exportAttributes(outfile, level, already_processed, namespace_, name_='bit')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_='', name_='bit', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='bit'):
        if self.num is not None and 'num' not in already_processed:
            already_processed.add('num')
            outfile.write(' num="%s"' % self.gds_format_integer(self.num, input_name='num'))
    def exportChildren(self, outfile, level, namespace_='', name_='bit', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='bit'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.num is not None and 'num' not in already_processed:
            already_processed.add('num')
            showIndent(outfile, level)
            outfile.write('num=%d,\n' % (self.num,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('num', node)
        if value is not None and 'num' not in already_processed:
            already_processed.add('num')
            try:
                self.num = int(value)
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class bit


class bitmap_description(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, bit=None):
        if bit is None:
            self.bit = []
        else:
            self.bit = bit
    def factory(*args_, **kwargs_):
        if bitmap_description.subclass:
            return bitmap_description.subclass(*args_, **kwargs_)
        else:
            return bitmap_description(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_bit(self): return self.bit
    def set_bit(self, bit): self.bit = bit
    def add_bit(self, value): self.bit.append(value)
    def insert_bit(self, index, value): self.bit[index] = value
    def hasContent_(self):
        if (
            self.bit
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='bitmap_description', namespacedef_='', pretty_print=True):
        # Check if we are at the root level and output the XML header
        if level == 0:
            outfile.write('<?xml version="1.0" encoding="%s"?>\n' % ExternalEncoding)
            outfile.write('\n')
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        # Check if we are at the root level and output attributes first before namespacedef
        if level == 0:
            outfile.write('<%s%s' % (namespace_, name_))
            already_processed = set()
            self.exportAttributes(outfile, level, already_processed, namespace_, name_='bitmap_description')
            outfile.write('%s' % (namespacedef_ and ' ' + namespacedef_ or ''))
        else:
            outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
            already_processed = set()
            self.exportAttributes(outfile, level, already_processed, namespace_, name_='bitmap_description')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='bitmap_description', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='bitmap_description'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='bitmap_description', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for bit_ in self.bit:
            bit_.export(outfile, level, namespace_, name_='bit', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='bitmap_description'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('bit=[\n')
        level += 1
        for bit_ in self.bit:
            showIndent(outfile, level)
            outfile.write('model_.bit(\n')
            bit_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'bit':
            obj_ = bit.factory()
            obj_.build(child_)
            self.bit.append(obj_)
# end class bitmap_description


class class_(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, num=None, valueOf_=None):
        self.num = _cast(int, num)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if class_.subclass:
            return class_.subclass(*args_, **kwargs_)
        else:
            return class_(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_num(self): return self.num
    def set_num(self, num): self.num = num
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='class', namespacedef_='', pretty_print=True):
        # Check if we are at the root level and output the XML header
        if level == 0:
            outfile.write('<?xml version="1.0" encoding="%s"?>\n' % ExternalEncoding)
            outfile.write('\n')
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        # Check if we are at the root level and output attributes first before namespacedef
        if level == 0:
            outfile.write('<%s%s' % (namespace_, name_))
            already_processed = set()
            self.exportAttributes(outfile, level, already_processed, namespace_, name_='class')
            outfile.write('%s' % (namespacedef_ and ' ' + namespacedef_ or ''))
        else:
            outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
            already_processed = set()
            self.exportAttributes(outfile, level, already_processed, namespace_, name_='class')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_='', name_='class', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='class'):
        if self.num is not None and 'num' not in already_processed:
            already_processed.add('num')
            outfile.write(' num="%s"' % self.gds_format_integer(self.num, input_name='num'))
    def exportChildren(self, outfile, level, namespace_='', name_='class', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='class'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.num is not None and 'num' not in already_processed:
            already_processed.add('num')
            showIndent(outfile, level)
            outfile.write('num=%d,\n' % (self.num,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('num', node)
        if value is not None and 'num' not in already_processed:
            already_processed.add('num')
            try:
                self.num = int(value)
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class class_


class class_values(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, class_=None):
        if class_ is None:
            self.class_ = []
        else:
            self.class_ = class_
    def factory(*args_, **kwargs_):
        if class_values.subclass:
            return class_values.subclass(*args_, **kwargs_)
        else:
            return class_values(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_class(self): return self.class_
    def set_class(self, class_): self.class_ = class_
    def add_class(self, value): self.class_.append(value)
    def insert_class(self, index, value): self.class_[index] = value
    def hasContent_(self):
        if (
            self.class_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='class_values', namespacedef_='', pretty_print=True):
        # Check if we are at the root level and output the XML header
        if level == 0:
            outfile.write('<?xml version="1.0" encoding="%s"?>\n' % ExternalEncoding)
            outfile.write('\n')
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        # Check if we are at the root level and output attributes first before namespacedef
        if level == 0:
            outfile.write('<%s%s' % (namespace_, name_))
            already_processed = set()
            self.exportAttributes(outfile, level, already_processed, namespace_, name_='class_values')
            outfile.write('%s' % (namespacedef_ and ' ' + namespacedef_ or ''))
        else:
            outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
            already_processed = set()
            self.exportAttributes(outfile, level, already_processed, namespace_, name_='class_values')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='class_values', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='class_values'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='class_values', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for class_ in self.class_:
            class_.export(outfile, level, namespace_, name_='class', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='class_values'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('class_=[\n')
        level += 1
        for class_ in self.class_:
            showIndent(outfile, level)
            outfile.write('model_.class_(\n')
            class_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'class':
            obj_ = class_.factory()
            obj_.build(child_)
            self.class_.append(obj_)
# end class class_values


class band(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, product=None, source=None, name=None, category=None, data_type=None, nlines=None, nsamps=None, fill_value=None, saturate_value=None, scale_factor=None, add_offset=None, short_name=None, long_name=None, file_name=None, pixel_size=None, data_units=None, valid_range=None, toa_reflectance=None, bitmap_description=None, class_values=None, calibrated_nt=None, app_version=None, production_date=None):
        self.product = _cast(None, product)
        self.source = _cast(None, source)
        self.name = _cast(None, name)
        self.category = _cast(None, category)
        self.data_type = _cast(None, data_type)
        self.nlines = _cast(int, nlines)
        self.nsamps = _cast(int, nsamps)
        self.fill_value = _cast(int, fill_value)
        self.saturate_value = _cast(int, saturate_value)
        self.scale_factor = _cast(float, scale_factor)
        self.add_offset = _cast(float, add_offset)
        self.short_name = short_name
        self.long_name = long_name
        self.file_name = file_name
        self.pixel_size = pixel_size
        self.data_units = data_units
        self.valid_range = valid_range
        self.toa_reflectance = toa_reflectance
        self.bitmap_description = bitmap_description
        self.class_values = class_values
        self.calibrated_nt = calibrated_nt
        self.app_version = app_version
        if isinstance(production_date, basestring):
            initvalue_ = datetime_.datetime.strptime(production_date, '%Y-%m-%dT%H:%M:%S')
        else:
            initvalue_ = production_date
        self.production_date = initvalue_
    def factory(*args_, **kwargs_):
        if band.subclass:
            return band.subclass(*args_, **kwargs_)
        else:
            return band(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_short_name(self): return self.short_name
    def set_short_name(self, short_name): self.short_name = short_name
    def get_long_name(self): return self.long_name
    def set_long_name(self, long_name): self.long_name = long_name
    def get_file_name(self): return self.file_name
    def set_file_name(self, file_name): self.file_name = file_name
    def get_pixel_size(self): return self.pixel_size
    def set_pixel_size(self, pixel_size): self.pixel_size = pixel_size
    def get_data_units(self): return self.data_units
    def set_data_units(self, data_units): self.data_units = data_units
    def get_valid_range(self): return self.valid_range
    def set_valid_range(self, valid_range): self.valid_range = valid_range
    def get_toa_reflectance(self): return self.toa_reflectance
    def set_toa_reflectance(self, toa_reflectance): self.toa_reflectance = toa_reflectance
    def get_bitmap_description(self): return self.bitmap_description
    def set_bitmap_description(self, bitmap_description): self.bitmap_description = bitmap_description
    def get_class_values(self): return self.class_values
    def set_class_values(self, class_values): self.class_values = class_values
    def get_calibrated_nt(self): return self.calibrated_nt
    def set_calibrated_nt(self, calibrated_nt): self.calibrated_nt = calibrated_nt
    def get_app_version(self): return self.app_version
    def set_app_version(self, app_version): self.app_version = app_version
    def get_production_date(self): return self.production_date
    def set_production_date(self, production_date): self.production_date = production_date
    def get_product(self): return self.product
    def set_product(self, product): self.product = product
    def get_source(self): return self.source
    def set_source(self, source): self.source = source
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_category(self): return self.category
    def set_category(self, category): self.category = category
    def get_data_type(self): return self.data_type
    def set_data_type(self, data_type): self.data_type = data_type
    def get_nlines(self): return self.nlines
    def set_nlines(self, nlines): self.nlines = nlines
    def get_nsamps(self): return self.nsamps
    def set_nsamps(self, nsamps): self.nsamps = nsamps
    def get_fill_value(self): return self.fill_value
    def set_fill_value(self, fill_value): self.fill_value = fill_value
    def get_saturate_value(self): return self.saturate_value
    def set_saturate_value(self, saturate_value): self.saturate_value = saturate_value
    def get_scale_factor(self): return self.scale_factor
    def set_scale_factor(self, scale_factor): self.scale_factor = scale_factor
    def get_add_offset(self): return self.add_offset
    def set_add_offset(self, add_offset): self.add_offset = add_offset
    def validate_sourceType(self, value):
        # Validate type sourceType, a restriction on xs:string.
        pass
    def validate_categoryType(self, value):
        # Validate type categoryType, a restriction on xs:string.
        pass
    def validate_dataType(self, value):
        # Validate type dataType, a restriction on xs:string.
        pass
    def hasContent_(self):
        if (
            self.short_name is not None or
            self.long_name is not None or
            self.file_name is not None or
            self.pixel_size is not None or
            self.data_units is not None or
            self.valid_range is not None or
            self.toa_reflectance is not None or
            self.bitmap_description is not None or
            self.class_values is not None or
            self.calibrated_nt is not None or
            self.app_version is not None or
            self.production_date is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='band', namespacedef_='', pretty_print=True):
        # Check if we are at the root level and output the XML header
        if level == 0:
            outfile.write('<?xml version="1.0" encoding="%s"?>\n' % ExternalEncoding)
            outfile.write('\n')
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        # Check if we are at the root level and output attributes first before namespacedef
        if level == 0:
            outfile.write('<%s%s' % (namespace_, name_))
            already_processed = set()
            self.exportAttributes(outfile, level, already_processed, namespace_, name_='band')
            outfile.write('%s' % (namespacedef_ and ' ' + namespacedef_ or ''))
        else:
            outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
            already_processed = set()
            self.exportAttributes(outfile, level, already_processed, namespace_, name_='band')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='band', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='band'):
        if self.product is not None and 'product' not in already_processed:
            already_processed.add('product')
            outfile.write(' product=%s' % (self.gds_format_string(quote_attrib(self.product).encode(ExternalEncoding), input_name='product'), ))
        if self.source is not None and 'source' not in already_processed:
            already_processed.add('source')
            outfile.write(' source=%s' % (quote_attrib(self.source), ))
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            outfile.write(' name=%s' % (self.gds_format_string(quote_attrib(self.name).encode(ExternalEncoding), input_name='name'), ))
        if self.category is not None and 'category' not in already_processed:
            already_processed.add('category')
            outfile.write(' category=%s' % (quote_attrib(self.category), ))
        if self.data_type is not None and 'data_type' not in already_processed:
            already_processed.add('data_type')
            outfile.write(' data_type=%s' % (quote_attrib(self.data_type), ))
        if self.nlines is not None and 'nlines' not in already_processed:
            already_processed.add('nlines')
            outfile.write(' nlines="%s"' % self.gds_format_integer(self.nlines, input_name='nlines'))
        if self.nsamps is not None and 'nsamps' not in already_processed:
            already_processed.add('nsamps')
            outfile.write(' nsamps="%s"' % self.gds_format_integer(self.nsamps, input_name='nsamps'))
        if self.fill_value is not None and 'fill_value' not in already_processed:
            already_processed.add('fill_value')
            outfile.write(' fill_value="%s"' % self.gds_format_integer(self.fill_value, input_name='fill_value'))
        if self.saturate_value is not None and 'saturate_value' not in already_processed:
            already_processed.add('saturate_value')
            outfile.write(' saturate_value="%s"' % self.gds_format_integer(self.saturate_value, input_name='saturate_value'))
        if self.scale_factor is not None and 'scale_factor' not in already_processed:
            already_processed.add('scale_factor')
            outfile.write(' scale_factor="%s"' % self.gds_format_float(self.scale_factor, input_name='scale_factor'))
        if self.add_offset is not None and 'add_offset' not in already_processed:
            already_processed.add('add_offset')
            outfile.write(' add_offset="%s"' % self.gds_format_float(self.add_offset, input_name='add_offset'))
    def exportChildren(self, outfile, level, namespace_='', name_='band', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.short_name is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sshort_name>%s</%sshort_name>%s' % (namespace_, self.gds_format_string(quote_xml(self.short_name).encode(ExternalEncoding), input_name='short_name'), namespace_, eol_))
        if self.long_name is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%slong_name>%s</%slong_name>%s' % (namespace_, self.gds_format_string(quote_xml(self.long_name).encode(ExternalEncoding), input_name='long_name'), namespace_, eol_))
        if self.file_name is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sfile_name>%s</%sfile_name>%s' % (namespace_, self.gds_format_string(quote_xml(self.file_name).encode(ExternalEncoding), input_name='file_name'), namespace_, eol_))
        if self.pixel_size is not None:
            self.pixel_size.export(outfile, level, namespace_, name_='pixel_size', pretty_print=pretty_print)
        if self.data_units is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdata_units>%s</%sdata_units>%s' % (namespace_, self.gds_format_string(quote_xml(self.data_units).encode(ExternalEncoding), input_name='data_units'), namespace_, eol_))
        if self.valid_range is not None:
            self.valid_range.export(outfile, level, namespace_, name_='valid_range', pretty_print=pretty_print)
        if self.toa_reflectance is not None:
            self.toa_reflectance.export(outfile, level, namespace_, name_='toa_reflectance', pretty_print=pretty_print)
        if self.bitmap_description is not None:
            self.bitmap_description.export(outfile, level, namespace_, name_='bitmap_description', pretty_print=pretty_print)
        if self.class_values is not None:
            self.class_values.export(outfile, level, namespace_, name_='class_values', pretty_print=pretty_print)
        if self.calibrated_nt is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scalibrated_nt>%s</%scalibrated_nt>%s' % (namespace_, self.gds_format_float(self.calibrated_nt, input_name='calibrated_nt'), namespace_, eol_))
        if self.app_version is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sapp_version>%s</%sapp_version>%s' % (namespace_, self.gds_format_string(quote_xml(self.app_version).encode(ExternalEncoding), input_name='app_version'), namespace_, eol_))
        if self.production_date is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sproduction_date>%s</%sproduction_date>%s' % (namespace_, self.gds_format_datetime(self.production_date, input_name='production_date'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='band'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.product is not None and 'product' not in already_processed:
            already_processed.add('product')
            showIndent(outfile, level)
            outfile.write('product="%s",\n' % (self.product,))
        if self.source is not None and 'source' not in already_processed:
            already_processed.add('source')
            showIndent(outfile, level)
            outfile.write('source="%s",\n' % (self.source,))
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            showIndent(outfile, level)
            outfile.write('name="%s",\n' % (self.name,))
        if self.category is not None and 'category' not in already_processed:
            already_processed.add('category')
            showIndent(outfile, level)
            outfile.write('category="%s",\n' % (self.category,))
        if self.data_type is not None and 'data_type' not in already_processed:
            already_processed.add('data_type')
            showIndent(outfile, level)
            outfile.write('data_type="%s",\n' % (self.data_type,))
        if self.nlines is not None and 'nlines' not in already_processed:
            already_processed.add('nlines')
            showIndent(outfile, level)
            outfile.write('nlines=%d,\n' % (self.nlines,))
        if self.nsamps is not None and 'nsamps' not in already_processed:
            already_processed.add('nsamps')
            showIndent(outfile, level)
            outfile.write('nsamps=%d,\n' % (self.nsamps,))
        if self.fill_value is not None and 'fill_value' not in already_processed:
            already_processed.add('fill_value')
            showIndent(outfile, level)
            outfile.write('fill_value=%d,\n' % (self.fill_value,))
        if self.saturate_value is not None and 'saturate_value' not in already_processed:
            already_processed.add('saturate_value')
            showIndent(outfile, level)
            outfile.write('saturate_value=%d,\n' % (self.saturate_value,))
        if self.scale_factor is not None and 'scale_factor' not in already_processed:
            already_processed.add('scale_factor')
            showIndent(outfile, level)
            outfile.write('scale_factor=%f,\n' % (self.scale_factor,))
        if self.add_offset is not None and 'add_offset' not in already_processed:
            already_processed.add('add_offset')
            showIndent(outfile, level)
            outfile.write('add_offset=%f,\n' % (self.add_offset,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.short_name is not None:
            showIndent(outfile, level)
            outfile.write('short_name=%s,\n' % quote_python(self.short_name).encode(ExternalEncoding))
        if self.long_name is not None:
            showIndent(outfile, level)
            outfile.write('long_name=%s,\n' % quote_python(self.long_name).encode(ExternalEncoding))
        if self.file_name is not None:
            showIndent(outfile, level)
            outfile.write('file_name=%s,\n' % quote_python(self.file_name).encode(ExternalEncoding))
        if self.pixel_size is not None:
            showIndent(outfile, level)
            outfile.write('pixel_size=model_.pixel_size(\n')
            self.pixel_size.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.data_units is not None:
            showIndent(outfile, level)
            outfile.write('data_units=%s,\n' % quote_python(self.data_units).encode(ExternalEncoding))
        if self.valid_range is not None:
            showIndent(outfile, level)
            outfile.write('valid_range=model_.valid_range(\n')
            self.valid_range.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.toa_reflectance is not None:
            showIndent(outfile, level)
            outfile.write('toa_reflectance=model_.toa_reflectance(\n')
            self.toa_reflectance.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.bitmap_description is not None:
            showIndent(outfile, level)
            outfile.write('bitmap_description=model_.bitmap_description(\n')
            self.bitmap_description.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.class_values is not None:
            showIndent(outfile, level)
            outfile.write('class_values=model_.class_values(\n')
            self.class_values.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.calibrated_nt is not None:
            showIndent(outfile, level)
            outfile.write('calibrated_nt=%f,\n' % self.calibrated_nt)
        if self.app_version is not None:
            showIndent(outfile, level)
            outfile.write('app_version=%s,\n' % quote_python(self.app_version).encode(ExternalEncoding))
        if self.production_date is not None:
            showIndent(outfile, level)
            outfile.write('production_date=model_.GeneratedsSuper.gds_parse_datetime("%s"),\n' % self.gds_format_datetime(self.production_date, input_name='production_date'))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('product', node)
        if value is not None and 'product' not in already_processed:
            already_processed.add('product')
            self.product = value
        value = find_attr_value_('source', node)
        if value is not None and 'source' not in already_processed:
            already_processed.add('source')
            self.source = value
            self.validate_sourceType(self.source)    # validate type sourceType
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.add('name')
            self.name = value
        value = find_attr_value_('category', node)
        if value is not None and 'category' not in already_processed:
            already_processed.add('category')
            self.category = value
            self.validate_categoryType(self.category)    # validate type categoryType
        value = find_attr_value_('data_type', node)
        if value is not None and 'data_type' not in already_processed:
            already_processed.add('data_type')
            self.data_type = value
            self.validate_dataType(self.data_type)    # validate type dataType
        value = find_attr_value_('nlines', node)
        if value is not None and 'nlines' not in already_processed:
            already_processed.add('nlines')
            try:
                self.nlines = int(value)
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('nsamps', node)
        if value is not None and 'nsamps' not in already_processed:
            already_processed.add('nsamps')
            try:
                self.nsamps = int(value)
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('fill_value', node)
        if value is not None and 'fill_value' not in already_processed:
            already_processed.add('fill_value')
            try:
                self.fill_value = int(value)
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('saturate_value', node)
        if value is not None and 'saturate_value' not in already_processed:
            already_processed.add('saturate_value')
            try:
                self.saturate_value = int(value)
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('scale_factor', node)
        if value is not None and 'scale_factor' not in already_processed:
            already_processed.add('scale_factor')
            try:
                self.scale_factor = float(value)
            except ValueError, exp:
                raise ValueError('Bad float/double attribute (scale_factor): %s' % exp)
        value = find_attr_value_('add_offset', node)
        if value is not None and 'add_offset' not in already_processed:
            already_processed.add('add_offset')
            try:
                self.add_offset = float(value)
            except ValueError, exp:
                raise ValueError('Bad float/double attribute (add_offset): %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'short_name':
            short_name_ = child_.text
            short_name_ = self.gds_validate_string(short_name_, node, 'short_name')
            self.short_name = short_name_
        elif nodeName_ == 'long_name':
            long_name_ = child_.text
            long_name_ = self.gds_validate_string(long_name_, node, 'long_name')
            self.long_name = long_name_
        elif nodeName_ == 'file_name':
            file_name_ = child_.text
            file_name_ = self.gds_validate_string(file_name_, node, 'file_name')
            self.file_name = file_name_
        elif nodeName_ == 'pixel_size':
            obj_ = pixel_size.factory()
            obj_.build(child_)
            self.pixel_size = obj_
        elif nodeName_ == 'data_units':
            data_units_ = child_.text
            data_units_ = self.gds_validate_string(data_units_, node, 'data_units')
            self.data_units = data_units_
        elif nodeName_ == 'valid_range':
            obj_ = valid_range.factory()
            obj_.build(child_)
            self.valid_range = obj_
        elif nodeName_ == 'toa_reflectance':
            obj_ = toa_reflectance.factory()
            obj_.build(child_)
            self.toa_reflectance = obj_
        elif nodeName_ == 'bitmap_description':
            obj_ = bitmap_description.factory()
            obj_.build(child_)
            self.bitmap_description = obj_
        elif nodeName_ == 'class_values':
            obj_ = class_values.factory()
            obj_.build(child_)
            self.class_values = obj_
        elif nodeName_ == 'calibrated_nt':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'calibrated_nt')
            self.calibrated_nt = fval_
        elif nodeName_ == 'app_version':
            app_version_ = child_.text
            app_version_ = self.gds_validate_string(app_version_, node, 'app_version')
            self.app_version = app_version_
        elif nodeName_ == 'production_date':
            sval_ = child_.text
            dval_ = self.gds_parse_datetime(sval_)
            self.production_date = dval_
# end class band


class espa_metadata(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, version=None, global_metadata=None, bands=None):
        self.version = _cast(None, version)
        self.global_metadata = global_metadata
        self.bands = bands
    def factory(*args_, **kwargs_):
        if espa_metadata.subclass:
            return espa_metadata.subclass(*args_, **kwargs_)
        else:
            return espa_metadata(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_global_metadata(self): return self.global_metadata
    def set_global_metadata(self, global_metadata): self.global_metadata = global_metadata
    def get_bands(self): return self.bands
    def set_bands(self, bands): self.bands = bands
    def get_version(self): return self.version
    def set_version(self, version): self.version = version
    def hasContent_(self):
        if (
            self.global_metadata is not None or
            self.bands is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='espa_metadata', namespacedef_='', pretty_print=True):
        # Check if we are at the root level and output the XML header
        if level == 0:
            outfile.write('<?xml version="1.0" encoding="%s"?>\n' % ExternalEncoding)
            outfile.write('\n')
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        # Check if we are at the root level and output attributes first before namespacedef
        if level == 0:
            outfile.write('<%s%s' % (namespace_, name_))
            already_processed = set()
            self.exportAttributes(outfile, level, already_processed, namespace_, name_='espa_metadata')
            outfile.write('%s' % (namespacedef_ and ' ' + namespacedef_ or ''))
        else:
            outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
            already_processed = set()
            self.exportAttributes(outfile, level, already_processed, namespace_, name_='espa_metadata')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='espa_metadata', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='espa_metadata'):
        if self.version is not None and 'version' not in already_processed:
            already_processed.add('version')
            outfile.write(' version=%s' % (self.gds_format_string(quote_attrib(self.version).encode(ExternalEncoding), input_name='version'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='espa_metadata', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.global_metadata is not None:
            self.global_metadata.export(outfile, level, namespace_, name_='global_metadata', pretty_print=pretty_print)
        if self.bands is not None:
            self.bands.export(outfile, level, namespace_, name_='bands', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='espa_metadata'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.version is not None and 'version' not in already_processed:
            already_processed.add('version')
            showIndent(outfile, level)
            outfile.write('version="%s",\n' % (self.version,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.global_metadata is not None:
            showIndent(outfile, level)
            outfile.write('global_metadata=model_.global_metadataType(\n')
            self.global_metadata.exportLiteral(outfile, level, name_='global_metadata')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.bands is not None:
            showIndent(outfile, level)
            outfile.write('bands=model_.bandsType(\n')
            self.bands.exportLiteral(outfile, level, name_='bands')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('version', node)
        if value is not None and 'version' not in already_processed:
            already_processed.add('version')
            self.version = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'global_metadata':
            obj_ = global_metadataType.factory()
            obj_.build(child_)
            self.global_metadata = obj_
        elif nodeName_ == 'bands':
            obj_ = bandsType.factory()
            obj_.build(child_)
            self.bands = obj_
# end class espa_metadata


class global_metadataType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, data_provider=None, satellite=None, instrument=None, acquisition_date=None, scene_center_time=None, level1_production_date=None, solar_angles=None, wrs=None, lpgs_metadata_file=None, corner=None, bounding_coordinates=None, projection_information=None, orientation_angle=None):
        self.data_provider = data_provider
        self.satellite = satellite
        self.instrument = instrument
        if isinstance(acquisition_date, basestring):
            initvalue_ = datetime_.datetime.strptime(acquisition_date, '%Y-%m-%d').date()
        else:
            initvalue_ = acquisition_date
        self.acquisition_date = initvalue_
        if isinstance(scene_center_time, basestring):
            initvalue_ = datetime_.datetime.strptime(scene_center_time, '%H:%M:%S').time()
        else:
            initvalue_ = scene_center_time
        self.scene_center_time = initvalue_
        if isinstance(level1_production_date, basestring):
            initvalue_ = datetime_.datetime.strptime(level1_production_date, '%Y-%m-%dT%H:%M:%S')
        else:
            initvalue_ = level1_production_date
        self.level1_production_date = initvalue_
        self.solar_angles = solar_angles
        self.wrs = wrs
        self.lpgs_metadata_file = lpgs_metadata_file
        if corner is None:
            self.corner = []
        else:
            self.corner = corner
        self.bounding_coordinates = bounding_coordinates
        self.projection_information = projection_information
        self.orientation_angle = orientation_angle
    def factory(*args_, **kwargs_):
        if global_metadataType.subclass:
            return global_metadataType.subclass(*args_, **kwargs_)
        else:
            return global_metadataType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_data_provider(self): return self.data_provider
    def set_data_provider(self, data_provider): self.data_provider = data_provider
    def get_satellite(self): return self.satellite
    def set_satellite(self, satellite): self.satellite = satellite
    def get_instrument(self): return self.instrument
    def set_instrument(self, instrument): self.instrument = instrument
    def get_acquisition_date(self): return self.acquisition_date
    def set_acquisition_date(self, acquisition_date): self.acquisition_date = acquisition_date
    def get_scene_center_time(self): return self.scene_center_time
    def set_scene_center_time(self, scene_center_time): self.scene_center_time = scene_center_time
    def get_level1_production_date(self): return self.level1_production_date
    def set_level1_production_date(self, level1_production_date): self.level1_production_date = level1_production_date
    def get_solar_angles(self): return self.solar_angles
    def set_solar_angles(self, solar_angles): self.solar_angles = solar_angles
    def get_wrs(self): return self.wrs
    def set_wrs(self, wrs): self.wrs = wrs
    def get_lpgs_metadata_file(self): return self.lpgs_metadata_file
    def set_lpgs_metadata_file(self, lpgs_metadata_file): self.lpgs_metadata_file = lpgs_metadata_file
    def get_corner(self): return self.corner
    def set_corner(self, corner): self.corner = corner
    def add_corner(self, value): self.corner.append(value)
    def insert_corner(self, index, value): self.corner[index] = value
    def get_bounding_coordinates(self): return self.bounding_coordinates
    def set_bounding_coordinates(self, bounding_coordinates): self.bounding_coordinates = bounding_coordinates
    def get_projection_information(self): return self.projection_information
    def set_projection_information(self, projection_information): self.projection_information = projection_information
    def get_orientation_angle(self): return self.orientation_angle
    def set_orientation_angle(self, orientation_angle): self.orientation_angle = orientation_angle
    def hasContent_(self):
        if (
            self.data_provider is not None or
            self.satellite is not None or
            self.instrument is not None or
            self.acquisition_date is not None or
            self.scene_center_time is not None or
            self.level1_production_date is not None or
            self.solar_angles is not None or
            self.wrs is not None or
            self.lpgs_metadata_file is not None or
            self.corner or
            self.bounding_coordinates is not None or
            self.projection_information is not None or
            self.orientation_angle is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='global_metadataType', namespacedef_='', pretty_print=True):
        # Check if we are at the root level and output the XML header
        if level == 0:
            outfile.write('<?xml version="1.0" encoding="%s"?>\n' % ExternalEncoding)
            outfile.write('\n')
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        # Check if we are at the root level and output attributes first before namespacedef
        if level == 0:
            outfile.write('<%s%s' % (namespace_, name_))
            already_processed = set()
            self.exportAttributes(outfile, level, already_processed, namespace_, name_='global_metadataType')
            outfile.write('%s' % (namespacedef_ and ' ' + namespacedef_ or ''))
        else:
            outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
            already_processed = set()
            self.exportAttributes(outfile, level, already_processed, namespace_, name_='global_metadataType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='global_metadataType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='global_metadataType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='global_metadataType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.data_provider is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdata_provider>%s</%sdata_provider>%s' % (namespace_, self.gds_format_string(quote_xml(self.data_provider).encode(ExternalEncoding), input_name='data_provider'), namespace_, eol_))
        if self.satellite is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%ssatellite>%s</%ssatellite>%s' % (namespace_, self.gds_format_string(quote_xml(self.satellite).encode(ExternalEncoding), input_name='satellite'), namespace_, eol_))
        if self.instrument is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sinstrument>%s</%sinstrument>%s' % (namespace_, self.gds_format_string(quote_xml(self.instrument).encode(ExternalEncoding), input_name='instrument'), namespace_, eol_))
        if self.acquisition_date is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sacquisition_date>%s</%sacquisition_date>%s' % (namespace_, self.gds_format_date(self.acquisition_date, input_name='acquisition_date'), namespace_, eol_))
        if self.scene_center_time is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sscene_center_time>%s</%sscene_center_time>%s' % (namespace_, self.gds_format_time(self.scene_center_time, input_name='scene_center_time'), namespace_, eol_))
        if self.level1_production_date is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%slevel1_production_date>%s</%slevel1_production_date>%s' % (namespace_, self.gds_format_datetime(self.level1_production_date, input_name='level1_production_date'), namespace_, eol_))
        if self.solar_angles is not None:
            self.solar_angles.export(outfile, level, namespace_, name_='solar_angles', pretty_print=pretty_print)
        if self.wrs is not None:
            self.wrs.export(outfile, level, namespace_, name_='wrs', pretty_print=pretty_print)
        if self.lpgs_metadata_file is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%slpgs_metadata_file>%s</%slpgs_metadata_file>%s' % (namespace_, self.gds_format_string(quote_xml(self.lpgs_metadata_file).encode(ExternalEncoding), input_name='lpgs_metadata_file'), namespace_, eol_))
        for corner_ in self.corner:
            corner_.export(outfile, level, namespace_, name_='corner', pretty_print=pretty_print)
        if self.bounding_coordinates is not None:
            self.bounding_coordinates.export(outfile, level, namespace_, name_='bounding_coordinates', pretty_print=pretty_print)
        if self.projection_information is not None:
            self.projection_information.export(outfile, level, namespace_, name_='projection_information', pretty_print=pretty_print)
        if self.orientation_angle is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sorientation_angle>%s</%sorientation_angle>%s' % (namespace_, self.gds_format_float(self.orientation_angle, input_name='orientation_angle'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='global_metadataType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.data_provider is not None:
            showIndent(outfile, level)
            outfile.write('data_provider=%s,\n' % quote_python(self.data_provider).encode(ExternalEncoding))
        if self.satellite is not None:
            showIndent(outfile, level)
            outfile.write('satellite=%s,\n' % quote_python(self.satellite).encode(ExternalEncoding))
        if self.instrument is not None:
            showIndent(outfile, level)
            outfile.write('instrument=%s,\n' % quote_python(self.instrument).encode(ExternalEncoding))
        if self.acquisition_date is not None:
            showIndent(outfile, level)
            outfile.write('acquisition_date=model_.GeneratedsSuper.gds_parse_date("%s"),\n' % self.gds_format_date(self.acquisition_date, input_name='acquisition_date'))
        if self.scene_center_time is not None:
            showIndent(outfile, level)
            outfile.write('scene_center_time=model_.GeneratedsSuper.gds_parse_time("%s"),\n' % self.gds_format_time(self.scene_center_time, input_name='scene_center_time'))
        if self.level1_production_date is not None:
            showIndent(outfile, level)
            outfile.write('level1_production_date=model_.GeneratedsSuper.gds_parse_datetime("%s"),\n' % self.gds_format_datetime(self.level1_production_date, input_name='level1_production_date'))
        if self.solar_angles is not None:
            showIndent(outfile, level)
            outfile.write('solar_angles=model_.solar_angles(\n')
            self.solar_angles.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.wrs is not None:
            showIndent(outfile, level)
            outfile.write('wrs=model_.wrs(\n')
            self.wrs.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.lpgs_metadata_file is not None:
            showIndent(outfile, level)
            outfile.write('lpgs_metadata_file=%s,\n' % quote_python(self.lpgs_metadata_file).encode(ExternalEncoding))
        showIndent(outfile, level)
        outfile.write('corner=[\n')
        level += 1
        for corner_ in self.corner:
            showIndent(outfile, level)
            outfile.write('model_.corner(\n')
            corner_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.bounding_coordinates is not None:
            showIndent(outfile, level)
            outfile.write('bounding_coordinates=model_.bounding_coordinates(\n')
            self.bounding_coordinates.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.projection_information is not None:
            showIndent(outfile, level)
            outfile.write('projection_information=model_.projection_information(\n')
            self.projection_information.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.orientation_angle is not None:
            showIndent(outfile, level)
            outfile.write('orientation_angle=%f,\n' % self.orientation_angle)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'data_provider':
            data_provider_ = child_.text
            data_provider_ = self.gds_validate_string(data_provider_, node, 'data_provider')
            self.data_provider = data_provider_
        elif nodeName_ == 'satellite':
            satellite_ = child_.text
            satellite_ = self.gds_validate_string(satellite_, node, 'satellite')
            self.satellite = satellite_
        elif nodeName_ == 'instrument':
            instrument_ = child_.text
            instrument_ = self.gds_validate_string(instrument_, node, 'instrument')
            self.instrument = instrument_
        elif nodeName_ == 'acquisition_date':
            sval_ = child_.text
            dval_ = self.gds_parse_date(sval_)
            self.acquisition_date = dval_
        elif nodeName_ == 'scene_center_time':
            sval_ = child_.text
            dval_ = self.gds_parse_time(sval_)
            self.scene_center_time = dval_
        elif nodeName_ == 'level1_production_date':
            sval_ = child_.text
            dval_ = self.gds_parse_datetime(sval_)
            self.level1_production_date = dval_
        elif nodeName_ == 'solar_angles':
            obj_ = solar_angles.factory()
            obj_.build(child_)
            self.solar_angles = obj_
        elif nodeName_ == 'wrs':
            obj_ = wrs.factory()
            obj_.build(child_)
            self.wrs = obj_
        elif nodeName_ == 'lpgs_metadata_file':
            lpgs_metadata_file_ = child_.text
            lpgs_metadata_file_ = self.gds_validate_string(lpgs_metadata_file_, node, 'lpgs_metadata_file')
            self.lpgs_metadata_file = lpgs_metadata_file_
        elif nodeName_ == 'corner':
            obj_ = corner.factory()
            obj_.build(child_)
            self.corner.append(obj_)
        elif nodeName_ == 'bounding_coordinates':
            obj_ = bounding_coordinates.factory()
            obj_.build(child_)
            self.bounding_coordinates = obj_
        elif nodeName_ == 'projection_information':
            obj_ = projection_information.factory()
            obj_.build(child_)
            self.projection_information = obj_
        elif nodeName_ == 'orientation_angle':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'orientation_angle')
            self.orientation_angle = fval_
# end class global_metadataType


class bandsType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, band=None):
        if band is None:
            self.band = []
        else:
            self.band = band
    def factory(*args_, **kwargs_):
        if bandsType.subclass:
            return bandsType.subclass(*args_, **kwargs_)
        else:
            return bandsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_band(self): return self.band
    def set_band(self, band): self.band = band
    def add_band(self, value): self.band.append(value)
    def insert_band(self, index, value): self.band[index] = value
    def hasContent_(self):
        if (
            self.band
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='bandsType', namespacedef_='', pretty_print=True):
        # Check if we are at the root level and output the XML header
        if level == 0:
            outfile.write('<?xml version="1.0" encoding="%s"?>\n' % ExternalEncoding)
            outfile.write('\n')
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        # Check if we are at the root level and output attributes first before namespacedef
        if level == 0:
            outfile.write('<%s%s' % (namespace_, name_))
            already_processed = set()
            self.exportAttributes(outfile, level, already_processed, namespace_, name_='bandsType')
            outfile.write('%s' % (namespacedef_ and ' ' + namespacedef_ or ''))
        else:
            outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
            already_processed = set()
            self.exportAttributes(outfile, level, already_processed, namespace_, name_='bandsType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='bandsType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='bandsType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='bandsType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for band_ in self.band:
            band_.export(outfile, level, namespace_, name_='band', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='bandsType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('band=[\n')
        level += 1
        for band_ in self.band:
            showIndent(outfile, level)
            outfile.write('model_.band(\n')
            band_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'band':
            obj_ = band.factory()
            obj_.build(child_)
            self.band.append(obj_)
# end class bandsType


GDSClassesMapping = {
    'global_metadata': global_metadataType,
    'bands': bandsType,
}


USAGE_TEXT = """
Usage: python <Parser>.py [ -s ] <in_xml_file>
"""


def usage():
    print USAGE_TEXT
    sys.exit(1)


def get_root_tag(node):
    tag = Tag_pattern_.match(node.tag).groups()[-1]
    rootClass = GDSClassesMapping.get(tag)
    if rootClass is None:
        rootClass = globals().get(tag)
    return tag, rootClass


def parse(inFileName, silence=False):
    doc = parsexml_(inFileName)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'data_provider'
        rootClass = xs_string
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    if not silence:
        sys.stdout.write('<?xml version="1.0" ?>\n')
        rootObj.export(
            sys.stdout, 0, name_=rootTag,
            namespacedef_='',
            pretty_print=True)
    return rootObj


def parseEtree(inFileName, silence=False):
    doc = parsexml_(inFileName)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'data_provider'
        rootClass = xs_string
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    mapping = {}
    rootElement = rootObj.to_etree(None, name_=rootTag, mapping_=mapping)
    reverse_mapping = rootObj.gds_reverse_node_mapping(mapping)
    if not silence:
        content = etree_.tostring(
            rootElement, pretty_print=True,
            xml_declaration=True, encoding="utf-8")
        sys.stdout.write(content)
        sys.stdout.write('\n')
    return rootObj, rootElement, mapping, reverse_mapping


def parseString(inString, silence=False):
    from StringIO import StringIO
    doc = parsexml_(StringIO(inString))
    rootNode = doc.getroot()
    roots = get_root_tag(rootNode)
    rootClass = roots[1]
    if rootClass is None:
        rootClass = xs_string
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    if not silence:
        sys.stdout.write('<?xml version="1.0" ?>\n')
        rootObj.export(
            sys.stdout, 0, name_="data_provider",
            namespacedef_='')
    return rootObj


def parseLiteral(inFileName, silence=False):
    doc = parsexml_(inFileName)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'data_provider'
        rootClass = xs_string
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    if not silence:
        sys.stdout.write('#from metadata_api import *\n\n')
        sys.stdout.write('import metadata_api as model_\n\n')
        sys.stdout.write('rootObj = model_.rootTag(\n')
        rootObj.exportLiteral(sys.stdout, 0, name_=rootTag)
        sys.stdout.write(')\n')
    return rootObj


# ESPA - Added a module method to build a namespace from its parts
def build_ns_def(xmlns=None, xmlns_xsi=None, schema_uri=None):
    if xmlns == None:
        raise ValueError("xmlns must be specified")

    if xmlns_xsi == None:
        raise ValueError("xmlns_xsi must be specified")

    if schema_uri == None:
        raise ValueError("schema_uri must be specified")

    ns_def = ('xmlns="%s" xmlns:xsi="%s"'
        ' xsi:schemaLocation="%s %s"') \
        % (xmlns, xmlns_xsi, xmlns, schema_uri)

    return ns_def


# ESPA - Added a module method to allow validation of the proposed output
def validate_xml(rootObj, xmlns=None, xmlns_xsi=None, schema_uri=None):

    try:
        ns_def = build_ns_def(xmlns, xmlns_xsi, schema_uri)

        schema_root = None

        # Search for the environment variable and use that if valid
        schema_path = os.getenv('ESPA_SCHEMA') 
        try:
            schema_root = etree.parse(schema_path)
        except Exception, e:
            print "Failed reading schema from ESPA_SCHEMA=" + schema_path
            print "Attempting espa-common installation directory"

        # Use the espa-common installation directory
        if schema_root == None:
            schema_name = schema_uri.split('/')[-1]
            schema_path = '/usr/local/espa-common/schema/%s' \
                % schema_name
            try:
                schema_root = etree.parse(schema_path)
            except Exception, e:
                print "Failed reading schema from " + schema_path
                print "Attempting schema_uri"

        # Use the schema_uri
        if schema_root == None:
            schema_source = urllib2.urlopen(schema_uri)
            schema_text = schema_source.read()
            schema_source.close()
            print "Using schema source %s for validation" % schema_uri
            schema_root = etree.fromstring(schema_text)

        if schema_root == None:
            raise RuntimeError("Failed to find ESPA XML schema")

        # Create the schema object to validate against
        schema = etree.XMLSchema(schema_root)

        # Create the lxml etree object to validate
        xml_io = StringIO.StringIO()
        rootObj.export(xml_io, 0, namespacedef_=ns_def, pretty_print=True)
        xml_io.flush()
        xml_text = xml_io.getvalue()
        xml_io.close()
        xml = etree.fromstring(xml_text)

        # Validate the etree against the schema 
        schema.assertValid(xml)

    except Exception, e:
        print "metadata_api Validation Error: " + str(e)


# ESPA - Added a module method to allow exporting from the module level with
#        validation
def export(outFile, rootObj, xmlns=None, xmlns_xsi=None, schema_uri=None):
    ns_def = build_ns_def(xmlns, xmlns_xsi, schema_uri)

    try:
        validate_xml(rootObj, xmlns, xmlns_xsi, schema_uri)
    except Exception, e:
        raise

    try:
        rootObj.export(outFile, 0, namespacedef_=ns_def, pretty_print=True)
    except Exception, e:
        raise Exception("metadata_api Export Error: " + str(e))


def main():
    args = sys.argv[1:]
    if len(args) == 1:
        parse(args[0])
    else:
        usage()


if __name__ == '__main__':
    #import pdb; pdb.set_trace()
    main()


__all__ = [
    "albers_proj_params",
    "band",
    "bandsType",
    "bit",
    "bitmap_description",
    "bounding_coordinates",
    "class_",
    "class_values",
    "corner",
    "corner_point",
    "espa_metadata",
    "global_metadataType",
    "pixel_size",
    "projection_information",
    "ps_proj_params",
    "solar_angles",
    "toa_reflectance",
    "utm_proj_params",
    "valid_range",
    "wrs"
]
